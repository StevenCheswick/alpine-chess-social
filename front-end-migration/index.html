<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Alpine Chess</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=DM+Sans:opsz,wght@9..40,300;9..40,400;9..40,500;9..40,600;9..40,700&family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
<!-- Chessground -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chessground@9.2.1/assets/chessground.base.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chessground@9.2.1/assets/chessground.brown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chessground@9.2.1/assets/chessground.cburnett.css">
<script>
tailwind.config = {
  theme: {
    extend: {
      fontFamily: {
        sans: ['DM Sans', 'system-ui', 'sans-serif'],
        mono: ['JetBrains Mono', 'monospace'],
      },
      fontSize: {
        meta: 'var(--font-meta)',
        label: 'var(--font-label)',
        body: 'var(--font-body)',
      },
      colors: {
        good: 'var(--good)',
        'good-dim': 'var(--good-dim)',
        bad: 'var(--bad)',
        accent: {
          DEFAULT: 'var(--accent)',
          bright: 'var(--accent-bright)',
          dim: 'var(--accent-dim)',
          glow: 'var(--accent-glow)',
        },
        muted: 'var(--text-muted)',
        secondary: 'var(--text-secondary)',
        'text-dim': 'var(--text-dim)',
        'move-book': 'var(--move-book)',
        'move-best': 'var(--move-best)',
        'move-excellent': 'var(--move-excellent)',
        'move-inaccuracy': 'var(--move-inaccuracy)',
        'move-mistake': 'var(--move-mistake)',
        'move-blunder': 'var(--move-blunder)',
      },
    },
  },
}
</script>
<style>
  :root {
    /* ─── Chrome / Accent ─── */
    --accent: #7dd3fc;
    --accent-bright: #38bdf8;
    --accent-dim: rgba(125,211,252,0.25);
    --accent-glow: rgba(125,211,252,0.07);

    /* ─── Surfaces ─── */
    --bg: #000000;
    --surface: rgba(10,10,10,0.95);
    --surface-hover: rgba(51,65,85,0.25);

    /* ─── Borders ─── */
    --border-subtle: rgba(51,65,85,0.3);
    --border-accent: rgba(125,211,252,0.35);

    /* ─── Text ─── */
    --text-primary: #e2e8f0;
    --text-secondary: #cbd5e1;
    --text-muted: #94a3b8;
    --text-dim: #64748b;

    /* ─── Semantic: Good / Bad ─── */
    --good: #60a5fa;
    --good-dim: rgba(96,165,250,0.7);
    --bad: #f87171;

    /* ─── Move Quality ─── */
    --move-book: #22d3ee;
    --move-best: #34d399;
    --move-excellent: #6ee7b7;
    --move-good: #94a3b8;
    --move-inaccuracy: #fbbf24;
    --move-mistake: #fb923c;
    --move-blunder: #ef4444;

    /* ─── Move Quality Backgrounds ─── */
    --move-book-bg: rgba(34,211,238,0.8);
    --move-best-bg: rgba(16,185,129,0.8);
    --move-excellent-bg: rgba(52,211,153,0.6);
    --move-good-bg: rgba(110,231,183,0.4);
    --move-inaccuracy-bg: rgba(251,191,36,0.6);
    --move-mistake-bg: rgba(251,146,60,0.6);
    --move-blunder-bg: rgba(239,68,68,0.6);

    /* ─── Chart Colors ─── */
    --chart-accuracy: #22d3ee;
    --chart-opening: #c084fc;
    --chart-middle: #f472b6;
    --chart-endgame: #2dd4bf;
    --chart-inaccuracy: #fde68a;
    --chart-mistake: #fdba74;
    --chart-blunder: #fca5a5;
    --chart-rating: #facc15;
    --chart-grid: rgba(51,65,85,0.2);
    --chart-tick: #475569;

    /* ─── Font Sizes ─── */
    --font-meta: 11px;
    --font-label: 12px;
    --font-body: 13px;

    /* ─── Chessboard ─── */
    --board-light: #e8edf3;
    --board-dark: #2c4a7c;

    /* ─── Gauge ─── */
    --gauge-track: rgba(51,65,85,0.5);
  }

  * { box-sizing: border-box; }
  body {
    background: var(--bg);
    font-family: 'DM Sans', system-ui, sans-serif;
    margin: 0;
    overflow-x: hidden;
  }

  /* ─── Scanline overlay ─── */
  body::after {
    content: '';
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 9999;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(0,0,0,0.03) 2px,
      rgba(0,0,0,0.03) 4px
    );
  }

  /* ─── Cards ─── */
  .card {
    background: var(--surface);
    border: 2px solid var(--border-accent);
    border-radius: 12px;
    position: relative;
    overflow: hidden;
  }
  .card::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: inherit;
    opacity: 0.03;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
    pointer-events: none;
  }

  .card-neutral {
    background: var(--surface);
    border: 1px solid var(--border-subtle);
    border-radius: 12px;
    position: relative;
    overflow: hidden;
  }
  .card-neutral::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: inherit;
    opacity: 0.03;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
    pointer-events: none;
  }

  /* ─── Animations ─── */
  .fade-up {
    animation: fadeUp 0.6s cubic-bezier(0.4, 0, 0.2, 1) both;
  }
  @keyframes fadeUp {
    from { opacity: 0; transform: translateY(16px); }
    to { opacity: 1; transform: translateY(0); }
  }

  /* ─── Gauge ─── */
  .gauge-ring { transform: rotate(-90deg); }
  .gauge-track { stroke: var(--gauge-track); }
  .gauge-fill {
    stroke-linecap: round;
    transition: stroke-dashoffset 1.2s cubic-bezier(0.4, 0, 0.2, 1);
  }

  /* ─── Nav ─── */
  .nav-link {
    position: relative;
    color: var(--text-dim);
    transition: color 0.2s;
    cursor: pointer;
    user-select: none;
  }
  .nav-link:hover { color: var(--text-muted); }
  .nav-link.active {
    color: var(--text-primary);
  }
  .nav-link.active::after {
    content: '';
    position: absolute;
    bottom: -8px;
    left: 0;
    right: 0;
    height: 1px;
    background: linear-gradient(90deg, transparent, var(--accent), transparent);
  }

  /* ─── Sidebar ─── */
  .sidebar-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px 12px;
    border-radius: 8px;
    color: var(--text-dim);
    font-size: var(--font-body);
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s;
  }
  .sidebar-item:hover { color: var(--text-muted); background: rgba(51,65,85,0.15); }
  .sidebar-item.active {
    color: var(--text-primary);
    background: var(--accent-glow);
    border: 1px solid var(--accent-dim);
  }
  .sidebar-item:not(.active) { border: 1px solid transparent; }

  /* ─── Mobile Bottom Nav ─── */
  .mobile-nav-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: var(--text-dim);
    transition: color 0.15s;
    padding: 4px 0;
    background: none;
    border: none;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
  }
  .mobile-nav-item.active { color: var(--accent); }
  .mobile-nav-item:hover { color: var(--text-muted); }

  /* ─── Game rows ─── */
  .game-row {
    transition: background 0.15s ease;
    cursor: pointer;
  }
  .game-row:hover { background: var(--surface-hover); }

  /* ─── Gradient lines ─── */
  .gradient-line {
    height: 1px;
    background: var(--border-subtle);
  }
  .gradient-line-accent {
    height: 1px;
    background: linear-gradient(90deg, var(--accent-dim), transparent);
  }

  /* ─── Page transitions ─── */
  .page { display: none; }
  .page.active { display: block; }

  /* ─── Chart ─── */
  .chart-wrap { position: relative; }
  .chart-wrap canvas { border-radius: 8px; }

  /* ─── Chessboard ─── */
  .chess-square-light { background: var(--board-light); }
  .chess-square-dark { background: var(--board-dark); }
  .chess-piece { font-size: 28px; line-height: 1; user-select: none; }

  /* ─── Eval bar ─── */
  .eval-bar {
    width: 24px;
    border-radius: 4px;
    overflow: hidden;
    position: relative;
    background: var(--border-subtle);
  }
  .eval-bar-fill {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: var(--text-primary);
    transition: height 0.4s ease;
  }

  /* ─── Move list ─── */
  .move-item {
    display: inline-block;
    padding: 2px 4px;
    border-radius: 3px;
    cursor: pointer;
    transition: background 0.1s;
  }
  .move-item:hover { background: rgba(51,65,85,0.3); }
  .move-item.active-move { background: rgba(16,185,129,0.15); color: var(--move-best); }
  .move-best { color: var(--move-best); }
  .move-excellent { color: var(--move-excellent); }
  .move-good { color: var(--move-good); }
  .move-inaccuracy { color: var(--move-inaccuracy); }
  .move-mistake { color: var(--move-mistake); }
  .move-blunder { color: var(--move-blunder); }
  .move-book { color: var(--move-book); }

  /* ─── Move quality backgrounds ─── */
  .bg-move-book { background: var(--move-book-bg); }
  .bg-move-best { background: var(--move-best-bg); }
  .bg-move-excellent { background: var(--move-excellent-bg); }
  .bg-move-good { background: var(--move-good-bg); }
  .bg-move-inaccuracy { background: var(--move-inaccuracy-bg); }
  .bg-move-mistake { background: var(--move-mistake-bg); }
  .bg-move-blunder { background: var(--move-blunder-bg); }

  /* ─── Scrollbar ─── */
  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: rgba(51,65,85,0.4); border-radius: 3px; }

  /* ─── Activity dot ─── */
  .activity-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    flex-shrink: 0;
    margin-top: 6px;
  }

  /* ─── Chessground boards: override square colors ─── */
  cg-board {
    background-color: #e8edf3 !important;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 2 2'%3E%3Crect width='2' height='2' fill='%23e8edf3'/%3E%3Crect x='1' width='1' height='1' fill='%232c4a7c'/%3E%3Crect y='1' width='1' height='1' fill='%232c4a7c'/%3E%3C/svg%3E") !important;
    background-size: 25% 25% !important;
  }
  cg-board square.last-move { background: rgba(125,211,252,0.25) !important; }

  cg-container {
    width: 100% !important;
    height: 100% !important;
  }
  #puzzleSolveBoard, #analysisBoard {
    position: relative;
  }

  /* ─── Mini boards (CSS grid) ─── */
  .mini-board {
    grid-template-rows: repeat(8, 1fr);
    grid-template-columns: repeat(8, 1fr);
  }
  .mini-board .sq-light { background: #e8edf3; }
  .mini-board .sq-dark  { background: #2c4a7c; }
  .mini-board .sq-piece { display: flex; align-items: center; justify-content: center; }
  .mini-board .sq-piece img { width: 85%; height: 85%; }
</style>
</head>
<body class="text-white">

<!-- ══════════════════════════════════════════ -->
<!-- LOGIN PAGE                                -->
<!-- ══════════════════════════════════════════ -->
<div id="login-page" class="min-h-screen flex items-center justify-center" style="display:none">
  <div class="w-full max-w-sm mx-auto px-6">
    <!-- Logo -->
    <div class="flex flex-col items-center mb-8">
      <div class="w-12 h-12 rounded-xl flex items-center justify-center mb-4" style="background:rgba(125,211,252,0.12); border:1px solid rgba(125,211,252,0.3)">
        <svg width="24" height="24" viewBox="0 0 32 32" fill="none"><path d="M4 26L12 10L16 16L20 10L28 26Z" stroke="var(--accent)" stroke-width="1.8" stroke-linejoin="round"/><line x1="12" y1="10" x2="12" y2="5" stroke="var(--accent)" stroke-width="1.8" stroke-linecap="round"/><line x1="9.5" y1="7" x2="14.5" y2="7" stroke="var(--accent)" stroke-width="1.8" stroke-linecap="round"/></svg>
      </div>
      <h1 class="text-xl font-semibold text-white tracking-tight">Alpine Chess</h1>
      <p class="text-label text-muted mt-1">Sign in to your account</p>
    </div>

    <!-- Form -->
    <form id="login-form" class="space-y-4">
      <div>
        <label class="block text-label text-muted mb-1.5 font-medium">Username</label>
        <input id="login-username" type="text" required autocomplete="username"
          class="w-full bg-slate-800/80 border border-slate-700 rounded-lg px-4 py-2.5 text-white text-body placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-sky-400/50 focus:border-sky-400 transition-colors"
          placeholder="username" />
      </div>
      <div>
        <label class="block text-label text-muted mb-1.5 font-medium">Password</label>
        <input id="login-password" type="password" required autocomplete="current-password"
          class="w-full bg-slate-800/80 border border-slate-700 rounded-lg px-4 py-2.5 text-white text-body placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-sky-400/50 focus:border-sky-400 transition-colors"
          placeholder="••••••••" />
      </div>
      <div id="login-error" class="text-meta text-bad hidden"></div>
      <button type="submit" id="login-btn"
        class="w-full py-2.5 rounded-lg font-medium text-white text-body transition-all bg-gradient-to-r from-sky-400 to-blue-500 hover:from-sky-300 hover:to-blue-400 shadow-[0_0_12px_rgba(56,189,248,0.3)]">
        Sign in
      </button>
    </form>
  </div>
</div>

<!-- ══════════════════════════════════════════ -->
<!-- LAYOUT: Sidebar + Content                 -->
<!-- ══════════════════════════════════════════ -->
<div id="app-shell" class="flex min-h-screen overflow-x-hidden" style="display:none">

  <!-- ─── Sidebar ─── -->
  <aside class="w-56 border-r border-slate-800/50 p-4 hidden lg:flex flex-col gap-1 shrink-0 sticky top-0 h-screen">
    <!-- Logo -->
    <div class="flex items-center gap-2.5 px-3 mb-6 mt-2">
      <div class="w-7 h-7 rounded-lg flex items-center justify-center" style="background:rgba(125,211,252,0.12); border:1px solid rgba(125,211,252,0.3)">
        <svg width="14" height="14" viewBox="0 0 32 32" fill="none"><path d="M4 26L12 10L16 16L20 10L28 26Z" stroke="var(--accent)" stroke-width="2.2" stroke-linejoin="round"/><line x1="12" y1="10" x2="12" y2="5" stroke="var(--accent)" stroke-width="2.2" stroke-linecap="round"/><line x1="9.5" y1="7" x2="14.5" y2="7" stroke="var(--accent)" stroke-width="2.2" stroke-linecap="round"/></svg>
      </div>
      <span class="text-sm font-semibold text-white tracking-tight">Alpine Chess</span>
    </div>

    <div onclick="switchPage('dashboard')" class="sidebar-item active" data-page="dashboard">
      <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7" rx="1"/><rect x="14" y="3" width="7" height="7" rx="1"/><rect x="3" y="14" width="7" height="7" rx="1"/><rect x="14" y="14" width="7" height="7" rx="1"/></svg>
      Dashboard
    </div>
    <div onclick="switchPage('puzzles')" class="sidebar-item" data-page="puzzles">
      <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/></svg>
      Puzzles
    </div>
    <div onclick="switchPage('endgames')" class="sidebar-item" data-page="endgames">
      <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>
      Endgames
    </div>
    <div onclick="switchPage('trainer')" class="sidebar-item" data-page="trainer">
      <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 19h16M4 15h16M4 11h8"/></svg>
      Trainer
    </div>
    <div onclick="switchPage('games')" class="sidebar-item" data-page="games">
      <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M2 12h5l3-9 4 18 3-9h5"/></svg>
      Games
    </div>
    <div onclick="switchPage('profile')" class="sidebar-item" data-page="profile">
      <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="8" r="4"/><path d="M4 20c0-4 4-7 8-7s8 3 8 7"/></svg>
      Profile
    </div>

  </aside>

  <!-- ─── Main Content ─── -->
  <main class="flex-1 p-4 lg:p-6 pb-20 lg:pb-6 max-w-[1100px] mx-auto">

<!-- ╔══════════════════════════════════════════╗ -->
<!-- ║  PAGE 1: DASHBOARD                       ║ -->
<!-- ╚══════════════════════════════════════════╝ -->
<div id="page-dashboard" class="page active">

  <!-- Not enough games gate -->
  <div id="dashMinGamesGate" class="card p-8 text-center" style="display:none">
    <svg class="w-16 h-16 text-muted mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"/></svg>
    <h2 class="text-xl font-semibold text-white mb-2">Not enough analyzed games</h2>
    <p class="text-muted mb-4">You need at least 100 analyzed games to view your dashboard.</p>
    <div class="max-w-xs mx-auto mb-2">
      <div class="flex justify-between text-sm text-muted mb-1">
        <span id="dashMinGamesCount">0 / 100 games</span>
        <span id="dashMinGamesPct">0%</span>
      </div>
      <div class="h-2 bg-slate-700 rounded-full overflow-hidden">
        <div class="h-full rounded-full transition-all" style="background:var(--accent);width:0%" id="dashMinGamesBar"></div>
      </div>
    </div>
    <button onclick="switchPage('games')" class="mt-4 px-4 py-2 rounded-lg text-sm font-medium text-white" style="background:var(--accent)">Analyze Games</button>
  </div>

  <div id="dashContent">
  <!-- Hero metrics -->
  <div class="grid grid-cols-2 lg:grid-cols-4 gap-3 mb-5 fade-up" style="animation-delay: 0.05s">

    <!-- Accuracy gauge -->
    <div class="card p-4">
      <div class="flex items-center gap-3">
        <div class="relative w-16 h-16 shrink-0">
          <svg class="gauge-ring w-full h-full" viewBox="0 0 120 120">
            <circle class="gauge-track" cx="60" cy="60" r="50" fill="none" stroke-width="7" />
            <circle class="gauge-fill" cx="60" cy="60" r="50" fill="none"
              stroke="url(#gGlacier)" stroke-width="7"
              stroke-dasharray="314.16" stroke-dashoffset="81.68" />
            <defs>
              <linearGradient id="gGlacier" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stop-color="var(--accent)" />
                <stop offset="100%" stop-color="var(--accent-bright)" />
              </linearGradient>
            </defs>
          </svg>
          <div class="absolute inset-0 flex items-center justify-center">
            <span id="dash-accuracy" class="text-lg font-bold font-mono" style="color:var(--accent)">—<span class="text-label">%</span></span>
          </div>
        </div>
        <div>
          <p class="text-meta uppercase tracking-[0.14em] text-secondary font-medium">Accuracy</p>
          <p class="text-label text-muted mt-0.5">All games</p>
        </div>
      </div>
    </div>

    <!-- Games Analyzed -->
    <div class="card p-4">
      <p class="text-meta uppercase tracking-[0.14em] text-secondary font-medium mb-1.5">Games</p>
      <p id="dash-games" class="text-2xl font-bold text-white font-mono leading-none">—</p>
      <p class="text-label text-muted mt-1">Analyzed</p>
    </div>

    <!-- Rating -->
    <div class="card p-4">
      <p class="text-meta uppercase tracking-[0.14em] text-secondary font-medium mb-1.5">Rating</p>
      <div class="flex items-baseline gap-1.5">
        <p id="dash-rating" class="text-2xl font-bold text-white font-mono leading-none">—</p>
        <span id="dash-rating-delta" class="text-label font-mono font-semibold text-good"></span>
      </div>
      <p class="text-label text-muted mt-1">Blitz</p>
    </div>

    <!-- Win Rate -->
    <div class="card p-4">
      <p class="text-meta uppercase tracking-[0.14em] text-secondary font-medium mb-1.5">Win Rate</p>
      <p id="dash-winrate" class="text-2xl font-bold text-good font-mono leading-none">—%</p>
      <p id="dash-wld" class="text-label text-muted mt-1">—</p>
    </div>

  </div>

  <!-- Move Quality Breakdown -->
  <div class="card p-4 mb-4 fade-up" style="animation-delay: 0.1s">
    <h2 class="text-xs font-semibold text-white mb-3">Move Quality Breakdown</h2>
    <div id="dash-mqbar" class="flex items-center gap-0.5 h-7 rounded-lg overflow-hidden"></div>
    <div id="dash-mqlegend" class="flex flex-wrap gap-x-3 gap-y-1 mt-2.5 text-meta text-muted justify-center"></div>
  </div>

  <!-- Charts row 1 -->
  <div class="grid grid-cols-1 lg:grid-cols-2 gap-3 mb-4">
    <div class="card p-4 fade-up" style="animation-delay: 0.12s">
      <div class="flex items-baseline justify-between mb-3">
        <h2 class="text-xs font-semibold text-white">Accuracy Over Time</h2>
        <span class="text-meta text-muted font-mono">Last 50 games</span>
      </div>
      <div class="chart-wrap h-40"><canvas id="accuracyChart"></canvas></div>
    </div>
    <div class="card p-4 fade-up" style="animation-delay: 0.15s">
      <div class="flex items-baseline justify-between mb-1">
        <h2 class="text-xs font-semibold text-white">Accuracy by Phase</h2>
      </div>
      <div class="flex gap-3 mb-2 text-meta text-muted">
        <span class="flex items-center gap-1"><span class="w-2 h-[2px] inline-block rounded" style="background:var(--chart-opening)"></span>Opening</span>
        <span class="flex items-center gap-1"><span class="w-2 h-[2px] inline-block rounded" style="background:var(--chart-middle)"></span>Middle</span>
        <span class="flex items-center gap-1"><span class="w-2 h-[2px] inline-block rounded" style="background:var(--chart-endgame)"></span>End</span>
      </div>
      <div class="chart-wrap h-40"><canvas id="phaseChart"></canvas></div>
    </div>
  </div>

  <!-- Charts row 2 -->
  <div class="grid grid-cols-1 lg:grid-cols-2 gap-3 mb-4">
    <div class="card p-4 fade-up" style="animation-delay: 0.18s">
      <div class="flex items-baseline justify-between mb-1">
        <h2 class="text-xs font-semibold text-white">Earliest Mistake</h2>
      </div>
      <div class="flex gap-3 mb-2 text-meta text-muted">
        <span class="flex items-center gap-1"><span class="w-2 h-[2px] inline-block rounded" style="background:var(--chart-inaccuracy)"></span>Inaccuracy</span>
        <span class="flex items-center gap-1"><span class="w-2 h-[2px] inline-block rounded" style="background:var(--chart-mistake)"></span>Mistake</span>
        <span class="flex items-center gap-1"><span class="w-2 h-[2px] inline-block rounded" style="background:var(--chart-blunder)"></span>Blunder</span>
      </div>
      <div class="chart-wrap h-36"><canvas id="mistakeChart"></canvas></div>
    </div>
    <div class="card p-4 fade-up" style="animation-delay: 0.2s">
      <div class="flex items-baseline justify-between mb-3">
        <h2 class="text-xs font-semibold text-white">Rating Over Time</h2>
        <span class="text-meta text-muted font-mono">Blitz</span>
      </div>
      <div class="chart-wrap h-40"><canvas id="ratingChart"></canvas></div>
    </div>
  </div>

  <!-- Game lists -->
  <div class="grid grid-cols-1 lg:grid-cols-2 gap-3 mb-4">
    <!-- Most Accurate -->
    <div class="card p-4 fade-up" style="animation-delay: 0.25s">
      <h2 class="text-xs font-semibold text-white mb-2">Most Accurate Games</h2>
      <div class="gradient-line-accent mb-2"></div>
      <div class="space-y-0" id="mostAccurateList"></div>
    </div>
    <!-- Least Accurate -->
    <div class="card p-4 fade-up" style="animation-delay: 0.28s">
      <h2 class="text-xs font-semibold text-white mb-2">Least Accurate Games</h2>
      <div class="gradient-line mb-2" style="background:rgba(239,68,68,0.25)"></div>
      <div class="space-y-0" id="leastAccurateList"></div>
    </div>
  </div>

  <!-- Opening habits -->
  <div class="grid grid-cols-1 lg:grid-cols-2 gap-3 mb-4">
    <div class="card p-4 fade-up" style="animation-delay: 0.32s">
      <h2 class="text-xs font-semibold text-white mb-0.5">Deepest Opening Prep</h2>
      <p class="text-meta text-muted mb-2">Longest lines with no inaccuracies</p>
      <div class="gradient-line-accent mb-2"></div>
      <div class="space-y-0" id="deepestPrepList"></div>
    </div>

    <div class="card p-4 fade-up" style="animation-delay: 0.35s">
      <h2 class="text-xs font-semibold text-white mb-0.5">Costliest Opening Habits</h2>
      <p class="text-meta text-muted mb-2">Mistakes you keep repeating</p>
      <div class="gradient-line mb-2" style="background:rgba(239,68,68,0.25)"></div>
      <div class="space-y-0" id="costliestHabitsList"></div>
    </div>
  </div>
  </div><!-- /dashContent -->
</div>

<!-- ╔══════════════════════════════════════════╗ -->
<!-- ║  PAGE 2: PUZZLES                         ║ -->
<!-- ╚══════════════════════════════════════════╝ -->
<div id="page-puzzles" class="page">

  <!-- Tactical Performance Stats -->
  <div class="card p-5 mb-4 fade-up" style="animation-delay: 0.05s">
    <h2 class="text-xs font-semibold text-white mb-4">Tactical Performance</h2>
    <div class="grid grid-cols-1 sm:grid-cols-3 gap-6" id="puzzleGauges">
      <div class="flex flex-col items-center justify-center"><span class="text-label text-muted">Loading...</span></div>
    </div>
  </div>

  <!-- Position Type Breakdown -->
  <div class="card p-5 mb-4 fade-up" style="animation-delay: 0.1s">
    <h2 class="text-xs font-semibold text-white mb-3">Performance by Position Type</h2>
    <div class="grid grid-cols-2 lg:grid-cols-3 gap-4" id="puzzlePositions"></div>
  </div>

  <!-- Theme Breakdown -->
  <div class="grid grid-cols-1 lg:grid-cols-2 gap-3 mb-4" id="puzzleThemeTables"></div>

  <!-- Theme Filters -->
  <div class="mb-3 fade-up" style="animation-delay: 0.2s" id="puzzleFilters"></div>

  <!-- Puzzle count -->
  <div class="flex items-center justify-between mb-3 fade-up" style="animation-delay: 0.22s" id="puzzleCountBar"></div>

  <!-- Puzzle List -->
  <div class="space-y-2 mb-4 fade-up" style="animation-delay: 0.25s" id="puzzleGrid"></div>

  <!-- Pagination -->
  <div class="flex items-center justify-center gap-1 mb-4" id="puzzlePagination"></div>

  <!-- Empty state -->
  <div id="puzzleEmptyState" class="hidden"></div>
</div>

<!-- Puzzle Solve View (replaces the page when active) -->
<div id="puzzleSolveView" class="page">
  <!-- Back button -->
  <button onclick="closePuzzleSolve()" class="flex items-center gap-2 text-muted hover:text-white transition-colors mb-5">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M15 19l-7-7 7-7"/></svg>
    Back to Puzzles
  </button>

  <div class="flex flex-col lg:flex-row gap-6">
    <!-- Left: Board -->
    <div class="flex-1 max-w-[560px]">
      <div id="puzzleSolveBoard" class="aspect-square w-full"></div>
      <!-- Status -->
      <div class="text-center mt-3" id="puzzleSolveStatus">
        <p class="text-body text-secondary">Find the best move</p>
      </div>
    </div>

    <!-- Right: Info panel -->
    <div class="lg:w-80 space-y-4">
      <!-- Themes -->
      <div class="card p-4" id="puzzleSolveThemes"></div>
      <!-- Source game -->
      <div class="card p-4" id="puzzleSolveSource"></div>
      <!-- Puzzle info -->
      <div class="card p-4" id="puzzleSolveInfo"></div>
      <!-- Actions -->
      <div class="flex flex-col gap-2" id="puzzleSolveActions"></div>
    </div>
  </div>
</div>

<!-- ╔══════════════════════════════════════════╗ -->
<!-- ║  PAGE 3: ENDGAMES                        ║ -->
<!-- ╚══════════════════════════════════════════╝ -->
<div id="page-endgames" class="page">

  <div class="card p-5 fade-up" style="animation-delay: 0.05s">
    <div class="mb-4">
      <h2 class="text-xs font-semibold text-white">By Endgame Type</h2>
      <p class="text-meta text-muted mt-1">Average centipawn loss per endgame. Lower is better.</p>
    </div>
    <div class="gradient-line-accent mb-3"></div>
    <div id="endgameContent" class="overflow-x-auto">
      <table class="w-full text-label min-w-[400px]">
        <thead>
          <tr class="text-meta text-muted uppercase tracking-wider">
            <th class="text-left py-2 pr-4 font-medium">Type</th>
            <th class="text-right py-2 px-3 font-medium">You</th>
            <th class="text-right py-2 px-3 font-medium">Opponent</th>
            <th class="text-right py-2 px-3 font-medium">Edge</th>
            <th class="text-right py-2 pl-3 font-medium">Games</th>
          </tr>
        </thead>
        <tbody class="text-secondary" id="endgameTableBody"></tbody>
      </table>
    </div>
  </div>
</div>

<!-- ╔══════════════════════════════════════════╗ -->
<!-- ║  PAGE 4: TRAINER                         ║ -->
<!-- ╚══════════════════════════════════════════╝ -->
<div id="page-trainer" class="page">

  <!-- Opening selection view -->
  <div id="trainerSelectView">
    <div class="mb-5 fade-up">
      <h1 class="text-2xl font-bold text-white">Opening Trainer</h1>
    </div>
    <div class="grid grid-cols-2 lg:grid-cols-3 gap-3" id="trainerGrid"></div>
  </div>

  <!-- Drill view -->
  <div id="trainerDrillView" style="display:none">
    <div class="flex items-center justify-between mb-4 fade-up">
      <button onclick="exitTrainerDrill()" class="flex items-center gap-1 text-label text-muted hover:text-white transition-colors">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 18l-6-6 6-6"/></svg>
        Back to Openings
      </button>
    </div>

    <div class="flex flex-col lg:flex-row gap-4">
      <div class="fade-up w-full lg:max-w-[520px]" style="animation-delay: 0.1s">
        <div class="w-full aspect-square rounded-lg overflow-hidden" id="trainerBoardWrap">
          <div id="trainerBoard" class="w-full h-full"></div>
        </div>
      </div>

      <div class="flex flex-col gap-3 w-full lg:flex-1">
        <div class="card p-4 fade-up" style="animation-delay: 0.12s">
          <div class="flex items-center justify-between mb-3">
            <span class="text-label text-white font-medium" id="trainerDrillCounter"></span>
            <span class="text-meta text-muted" id="trainerVarCounter" style="display:none">Main line</span>
          </div>
          <div class="flex flex-wrap gap-2">
            <button onclick="trainerHint()" id="btnTrainerHint" class="px-3 py-1.5 text-label font-medium rounded-lg border border-slate-700 text-secondary hover:text-white hover:border-slate-500 transition-colors">Hint</button>
            <button onclick="trainerRetry()" id="btnTrainerRetry" class="px-3 py-1.5 text-label font-medium rounded-lg border border-slate-700 text-secondary hover:text-white hover:border-slate-500 transition-colors" style="display:none">Retry</button>
            <button onclick="startDeepDrill()" id="btnTrainerDeepDrill" class="px-3 py-1.5 text-label font-medium rounded-lg border border-sky-500/50 text-sky-400 bg-sky-500/10 hover:bg-sky-500/20 hover:border-sky-400/60 transition-colors" style="display:none">Drill Deeper</button>
            <button onclick="trainerNext()" id="btnTrainerNext" class="px-3 py-1.5 text-label font-medium rounded-lg border border-sky-500/50 text-white bg-sky-500/20 hover:bg-sky-500/30 transition-colors" style="display:none">Next Puzzle</button>
          </div>
          <div class="mt-3">
            <div class="flex items-center justify-between text-meta text-muted mb-1">
              <span id="trainerProgressLabel">0/0 completed</span>
              <span class="font-mono" id="trainerProgressPct">0%</span>
            </div>
            <div class="h-1.5 rounded-full bg-slate-800/60 overflow-hidden">
              <div class="h-full rounded-full transition-all" style="background: var(--accent)" id="trainerProgressBar"></div>
            </div>
          </div>
        </div>

        <div class="card p-4 fade-up" style="animation-delay: 0.14s">
          <h3 class="text-xs font-semibold text-white mb-2.5">Moves</h3>
          <div class="overflow-y-auto pr-1 text-body font-mono leading-relaxed" style="max-height: 200px;" id="trainerMoveList"></div>
        </div>

        <div class="card p-3 fade-up" id="trainerStatusCard" style="animation-delay: 0.16s; min-height: 52px;">
          <h3 class="text-sm font-semibold" id="trainerStatusTitle"></h3>
          <p class="text-muted text-sm mt-0.5" id="trainerStatusMsg"></p>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- ╔══════════════════════════════════════════╗ -->
<!-- ║  PAGE 5: GAMES LIST                      ║ -->
<!-- ╚══════════════════════════════════════════╝ -->
<div id="page-games" class="page">

  <div class="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-3 mb-6 fade-up">
    <p class="text-base text-white font-medium" id="gamesStats">Loading...</p>
    <div class="flex items-center gap-2" id="gamesActions">
      <button id="btnSyncGames" onclick="gamesSync()" class="px-4 py-2 text-sm font-medium rounded-lg border border-slate-700 text-secondary hover:text-white hover:border-slate-500 transition-colors flex items-center gap-2">
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/></svg>
        Sync Games
      </button>
      <button id="btnLoadHistory" onclick="gamesBackfill()" class="px-4 py-2 text-sm font-medium rounded-lg border border-slate-700 text-secondary hover:text-white hover:border-slate-500 transition-colors flex items-center gap-2" style="display:none">
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
        Load More History
      </button>
      <button id="btnAnalyze" onclick="gamesAnalyze()" class="px-4 py-2 text-sm font-medium rounded-lg text-white transition-colors flex items-center gap-2" style="background:var(--accent-bright); display:none">
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 15a4 4 0 004 4h9a5 5 0 10-.1-9.999 5.002 5.002 0 10-9.78 2.096A4.001 4.001 0 003 15z"/></svg>
        <span id="btnAnalyzeText">Analyze</span>
      </button>
    </div>
  </div>

  <!-- Feedback message -->
  <div id="gamesFeedback" class="hidden mb-3 px-4 py-2 rounded-lg text-label flex items-center gap-2"></div>

  <!-- Tag filters -->
  <div class="flex items-center gap-1.5 flex-wrap mb-4 fade-up" style="animation-delay:0.05s" id="gamesTagFilters"></div>

  <!-- Game list -->
  <div class="space-y-2" id="gamesList"></div>

  <!-- Pagination -->
  <div class="flex items-center justify-between mt-4 fade-up" style="animation-delay:0.15s" id="gamesPagination"></div>
</div>

<!-- ╔══════════════════════════════════════════╗ -->
<!-- ║  PAGE 6: GAME ANALYSIS (detail)          ║ -->
<!-- ╚══════════════════════════════════════════╝ -->
<div id="page-analysis" class="page">

  <!-- Back button -->
  <div class="mb-3 fade-up">
    <button id="analysisBackBtn" onclick="analysisGoBack()" class="flex items-center gap-1 text-label text-muted hover:text-white transition-colors">
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 18l-6-6 6-6"/></svg>
      <span id="analysisBackLabel">Back to Games</span>
    </button>
  </div>

  <!-- Game header -->
  <div class="card p-4 mb-4 fade-up" style="animation-delay: 0.05s" id="analysisHeader">
    <div class="flex items-center justify-center py-4"><span class="text-label text-muted">Select a game to analyze</span></div>
  </div>

  <div class="flex flex-col lg:flex-row gap-4">

    <!-- Board + Eval bar -->
    <div class="flex flex-col gap-2 fade-up w-full lg:max-w-[548px]" style="animation-delay: 0.1s">
      <div class="flex gap-1.5" id="analysisBoardRow">
        <!-- Eval bar -->
        <div class="eval-bar rounded-md" id="analysisEvalBar">
          <div class="eval-bar-fill" id="analysisEvalFill" style="height: 50%"></div>
          <div class="absolute inset-x-0 top-2 text-center text-meta font-mono font-bold text-muted" id="analysisEvalText">0.0</div>
        </div>

        <!-- Chessboard -->
        <div class="flex-1 aspect-square max-w-[520px] rounded-lg overflow-hidden" id="chessboardWrap">
          <div id="chessboard" class="w-full h-full"></div>
        </div>
      </div>
      <!-- Nav buttons under board -->
      <div class="grid grid-cols-4 gap-1 mt-1" id="analysisNavBtns" style="margin-left: 26px;">
        <button onclick="analysisNav('first')" class="py-1.5 text-label text-muted rounded border border-slate-800 hover:border-slate-600 hover:text-white hover:bg-slate-800/50 transition-colors" title="First">⟨⟨</button>
        <button onclick="analysisNav('prev')" class="py-1.5 text-label text-muted rounded border border-slate-800 hover:border-slate-600 hover:text-white hover:bg-slate-800/50 transition-colors" title="Previous">⟨</button>
        <button onclick="analysisNav('next')" class="py-1.5 text-label text-muted rounded border border-slate-800 hover:border-slate-600 hover:text-white hover:bg-slate-800/50 transition-colors" title="Next">⟩</button>
        <button onclick="analysisNav('last')" class="py-1.5 text-label text-muted rounded border border-slate-800 hover:border-slate-600 hover:text-white hover:bg-slate-800/50 transition-colors" title="Last">⟩⟩</button>
      </div>
    </div>

    <!-- Right panel -->
    <div class="flex flex-col gap-3 w-full lg:flex-1">

      <!-- Move Quality — You vs Opponent -->
      <div class="card p-4 fade-up" style="animation-delay: 0.12s" id="analysisMoveQuality">
        <h3 class="text-xs font-semibold text-white mb-3">Move Quality</h3>
        <div id="analysisMqGrid"></div>
      </div>

      <!-- Move list -->
      <div class="card p-4 fade-up flex-1 overflow-hidden" style="animation-delay: 0.15s">
        <h3 class="text-xs font-semibold text-white mb-2.5">Moves</h3>
        <div class="overflow-y-auto pr-1 text-body font-mono leading-relaxed" style="max-height: 220px;" id="moveList"></div>
      </div>
    </div>
  </div>
</div>

<!-- ╔══════════════════════════════════════════╗ -->
<!-- ║  PAGE 3: PROFILE                         ║ -->
<!-- ╚══════════════════════════════════════════╝ -->
<div id="page-profile" class="page">

  <!-- Profile header -->
  <div class="card p-6 mb-4 fade-up" style="animation-delay: 0.05s" id="profileCard">
    <div class="flex items-center justify-center py-8"><span class="text-label text-muted">Loading profile...</span></div>
  </div>
</div>

<!-- ══════════════════════════════════════════ -->
<!-- EDIT PROFILE MODAL                        -->
<!-- ══════════════════════════════════════════ -->
<div id="edit-profile-modal" class="fixed inset-0 z-50 flex items-center justify-center" style="display:none">
  <div class="absolute inset-0 bg-black/60 backdrop-blur-sm" onclick="closeEditProfile()"></div>
  <div class="card p-6 w-full max-w-md mx-4 max-h-[90vh] overflow-y-auto relative z-10">
    <div class="flex items-center justify-between mb-5">
      <h2 class="text-lg font-bold text-white">Edit Profile</h2>
      <button onclick="closeEditProfile()" class="text-muted hover:text-white transition-colors" id="edit-profile-close-btn">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M18 6L6 18M6 6l12 12"/></svg>
      </button>
    </div>

    <form id="edit-profile-form" class="space-y-4">
      <div id="edit-profile-error" class="p-3 rounded-lg text-meta hidden" style="background:rgba(248,113,113,0.1); border:1px solid rgba(248,113,113,0.3); color:var(--bad)"></div>

      <!-- Display Name -->
      <div>
        <label class="block text-label text-muted mb-1.5 font-medium">Display Name</label>
        <input id="edit-displayName" type="text" maxlength="50"
          class="w-full bg-slate-800/80 border border-slate-700 rounded-lg px-4 py-2.5 text-white text-body placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-sky-400/50 focus:border-sky-400 transition-colors"
          placeholder="Your display name" />
        <p class="mt-1 text-meta text-muted"><span id="edit-displayName-count">0</span>/50</p>
      </div>

      <!-- Bio -->
      <div>
        <label class="block text-label text-muted mb-1.5 font-medium">Bio</label>
        <textarea id="edit-bio" maxlength="500" rows="3"
          class="w-full bg-slate-800/80 border border-slate-700 rounded-lg px-4 py-2.5 text-white text-body placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-sky-400/50 focus:border-sky-400 transition-colors resize-none"
          placeholder="Tell us about yourself..."></textarea>
        <p class="mt-1 text-meta text-muted"><span id="edit-bio-count">0</span>/500</p>
      </div>

      <!-- Linked Accounts -->
      <div class="pt-4" style="border-top:1px solid var(--border-subtle)">
        <h3 class="text-label text-muted font-medium mb-3">Linked Accounts</h3>
        <div>
          <label class="block text-label text-muted mb-1.5 font-medium">Chess.com Username</label>
          <div class="flex gap-2">
            <div class="w-10 h-10 bg-green-600 rounded-lg flex items-center justify-center shrink-0">
              <span class="text-white text-label font-bold">C</span>
            </div>
            <input id="edit-chesscom" type="text" maxlength="50"
              class="flex-1 bg-slate-800/80 border border-slate-700 rounded-lg px-4 py-2.5 text-white text-body placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-sky-400/50 focus:border-sky-400 transition-colors"
              placeholder="your_chess_com_username" />
          </div>
          <p class="mt-1 text-meta text-muted">Enter your Chess.com username to sync your games</p>
        </div>
      </div>

      <!-- Buttons -->
      <div class="flex gap-3 pt-4">
        <button type="button" onclick="closeEditProfile()"
          class="flex-1 py-2.5 rounded-lg font-medium text-body text-muted border border-slate-700 hover:bg-slate-800 transition-colors">
          Cancel
        </button>
        <button type="submit" id="edit-profile-save-btn"
          class="flex-1 py-2.5 rounded-lg font-medium text-white text-body transition-all bg-gradient-to-r from-sky-400 to-blue-500 hover:from-sky-300 hover:to-blue-400 shadow-[0_0_12px_rgba(56,189,248,0.3)]">
          Save Changes
        </button>
      </div>
    </form>

    <!-- Danger Zone -->
    <div class="mt-6 pt-5" style="border-top:1px solid rgba(248,113,113,0.2)">
      <h3 class="text-label font-medium mb-3" style="color:var(--bad)">Danger Zone</h3>
      <div id="delete-account-section">
        <button onclick="showDeleteConfirm()"
          class="px-4 py-2 rounded-lg text-label font-medium transition-colors" id="delete-account-btn"
          style="background:rgba(248,113,113,0.1); border:1px solid rgba(248,113,113,0.3); color:var(--bad)">
          Delete Account
        </button>
      </div>
      <div id="delete-confirm-section" class="hidden space-y-3">
        <p class="text-label" style="color:var(--bad)">This will permanently delete your account and all associated data. This cannot be undone.</p>
        <div class="flex gap-3">
          <button onclick="hideDeleteConfirm()"
            class="px-4 py-2 rounded-lg text-label font-medium text-muted border border-slate-700 hover:bg-slate-800 transition-colors">
            Cancel
          </button>
          <button onclick="confirmDeleteAccount()" id="confirm-delete-btn"
            class="px-4 py-2 rounded-lg text-label font-medium text-white transition-colors"
            style="background:#dc2626">
            Confirm Delete
          </button>
        </div>
      </div>
    </div>
  </div>
</div>

  </main>
</div>

<script>
// ══════════════════════════════════════════
// CONFIG
// ══════════════════════════════════════════
const API_URL = window.location.hostname === 'localhost'
  ? 'http://localhost:8000'
  : 'https://3vzqmqtxf8.us-east-1.awsapprunner.com';

// ══════════════════════════════════════════
// CHESSGROUND + CHESS.JS (loaded async)
// ══════════════════════════════════════════
let Chessground = null;
let Chess = null;
let _cgInstance = null; // current chessground board instance
let _chessInstance = null; // chess.js game for replaying moves
let _analysisMoveIndex = -1; // -1 = starting position
let _analysisPositions = []; // FEN at each half-move index
let _analysisMoveCount = 0;

(async function loadChessLibs() {
  try {
    const [cgMod, chessMod] = await Promise.all([
      import('https://esm.sh/chessground@9.2.1'),
      import('https://esm.sh/chess.js@1.0.0-beta.8'),
    ]);
    Chessground = cgMod.Chessground;
    Chess = chessMod.Chess;
    console.log('Chessground + chess.js loaded');
  } catch (err) {
    console.error('Failed to load chess libs:', err);
  }
})();

// ══════════════════════════════════════════
// RESPONSIVE BOARD RESIZE
// ══════════════════════════════════════════
function resizeBoards() {
  // Resize analysis board
  const cbWrap = document.getElementById('chessboardWrap');
  if (cbWrap) {
    const w = cbWrap.clientWidth;
    const inner = document.getElementById('chessboard');
    if (inner && w > 0) { inner.style.width = w + 'px'; inner.style.height = w + 'px'; }
    // Sync eval bar height to board
    const evalBar = document.getElementById('analysisEvalBar');
    if (evalBar && w > 0) { evalBar.style.height = w + 'px'; }
  }
  // Resize trainer board
  const tbWrap = document.getElementById('trainerBoardWrap');
  if (tbWrap) {
    const w = tbWrap.clientWidth;
    const inner = document.getElementById('trainerBoard');
    if (inner && w > 0) { inner.style.width = w + 'px'; inner.style.height = w + 'px'; }
  }
  // Redraw active Chessground instances
  if (_cgInstance) _cgInstance.redrawAll();
  if (_trainerCgInstance) _trainerCgInstance.redrawAll();
  if (_solveCg) _solveCg.redrawAll();
}
let _resizeTimer = null;
window.addEventListener('resize', () => {
  clearTimeout(_resizeTimer);
  _resizeTimer = setTimeout(resizeBoards, 150);
});

// ══════════════════════════════════════════
// PAGE SWITCHING
// ══════════════════════════════════════════
function switchPage(name, skipHash) {
  // Clean up puzzle solve board if leaving
  if (_solveCg) { _solveCg.destroy(); _solveCg = null; }

  document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
  document.querySelectorAll('.sidebar-item').forEach(s => s.classList.remove('active'));
  document.querySelectorAll('.mobile-nav-item').forEach(s => s.classList.remove('active'));
  document.getElementById('page-' + name).classList.add('active');
  document.querySelector(`.sidebar-item[data-page="${name}"]`)?.classList.add('active');
  document.querySelector(`.mobile-nav-item[data-page="${name}"]`)?.classList.add('active');

  if (!skipHash) location.hash = name;

  // Re-trigger animations
  document.querySelectorAll('#page-' + name + ' .fade-up').forEach(el => {
    el.style.animation = 'none';
    el.offsetHeight;
    el.style.animation = '';
  });

  // Init charts/board on first visit
  if (name === 'dashboard' && !window._dashInit) initDashboard();
  if (name === 'puzzles' && !window._puzzlesInit) initPuzzles();
  if (name === 'endgames' && !window._endgamesInit) initEndgames();
  if (name === 'trainer' && !window._trainerInit) initTrainer();
  if (name === 'games' && !window._gamesInit) initGames();
  if (name === 'analysis' && !window._analysisInit) initAnalysis();
  if (name === 'profile' && !window._profileInit) initProfile();

  // Resize boards after page is visible
  setTimeout(resizeBoards, 50);
}

// Handle browser back/forward + hash links
window.addEventListener('hashchange', () => {
  const page = location.hash.slice(1) || 'dashboard';
  if (document.getElementById('page-' + page)) switchPage(page, true);
});

// Navigate to hash on initial load — deferred to end of script (see bottom)

// ══════════════════════════════════════════
// DESIGN TOKEN READER
// ══════════════════════════════════════════
const T = (name) => getComputedStyle(document.documentElement).getPropertyValue(name).trim();

// ══════════════════════════════════════════
// CHART HELPERS
// ══════════════════════════════════════════
Chart.defaults.font.family = "'DM Sans', system-ui, sans-serif";
Chart.defaults.color = T('--text-dim');
Chart.defaults.borderColor = T('--border-subtle');
Chart.defaults.plugins.legend.display = false;
Chart.defaults.plugins.tooltip.backgroundColor = '#0f172a';
Chart.defaults.plugins.tooltip.borderColor = '#1e293b';
Chart.defaults.plugins.tooltip.borderWidth = 1;
Chart.defaults.plugins.tooltip.cornerRadius = 6;
Chart.defaults.plugins.tooltip.titleFont = { family: "'DM Sans'", size: 10 };
Chart.defaults.plugins.tooltip.bodyFont = { family: "'JetBrains Mono'", size: 11 };
Chart.defaults.plugins.tooltip.padding = 8;

const dates = Array.from({length:50},(_,i)=>{const d=new Date(2025,0,1+i*7);return d.toLocaleDateString('en',{month:'short',day:'numeric'})});

function wave(base, amp, freq, phase, len) {
  return Array.from({length:len},(_,i)=>+(base+amp*Math.sin(i*freq+phase)+(Math.random()-0.5)*3).toFixed(1));
}

const axisOpts = {
  grid: { color: T('--chart-grid'), drawBorder: false },
  ticks: { font: { family: "'JetBrains Mono'", size: 9 }, color: T('--chart-tick'), padding: 4 },
  border: { display: false },
};

// ══════════════════════════════════════════
// DASHBOARD INIT
// ══════════════════════════════════════════
async function initDashboard() {
  // Destroy existing charts if re-initing
  ['accuracyChart', 'phaseChart', 'mistakeChart', 'ratingChart'].forEach(id => {
    const existing = Chart.getChart(document.getElementById(id));
    if (existing) existing.destroy();
  });
  window._dashInit = true;

  // ── Auth ──
  const token = localStorage.getItem('alpine_token');
  if (!token) { console.warn('No auth token'); return; }
  const headers = { 'Authorization': 'Bearer ' + token };

  // ── Fetch stats ──
  let res, s;
  try {
    res = await fetch(API_URL + '/api/games/stats', { headers });
    if (!res.ok) { console.error('Stats fetch failed:', res.status); return; }
    s = await res.json();
  } catch (err) {
    console.error('Dashboard fetch error (is backend running?):', err.message);
    return;
  }

  // ── MIN_GAMES gate (same as React frontend) ──
  const MIN_GAMES = 100;
  const totalGames = s.totalAnalyzedGames || 0;
  if (totalGames < MIN_GAMES) {
    const pct = Math.round((totalGames / MIN_GAMES) * 100);
    document.getElementById('dashMinGamesCount').textContent = totalGames + ' / ' + MIN_GAMES + ' games';
    document.getElementById('dashMinGamesPct').textContent = pct + '%';
    document.getElementById('dashMinGamesBar').style.width = pct + '%';
    document.getElementById('dashMinGamesGate').style.display = '';
    document.getElementById('dashContent').style.display = 'none';
    return;
  }
  document.getElementById('dashMinGamesGate').style.display = 'none';
  document.getElementById('dashContent').style.display = '';

  // ── Hero cards ──
  const accArr = s.accuracyOverTime || [];
  const avgAcc = accArr.length ? Math.round(accArr.reduce((a,d) => a + d.accuracy, 0) / accArr.length) : 0;
  const GAUGE_C = 2 * Math.PI * 50;
  document.getElementById('dash-accuracy').innerHTML = avgAcc + '<span class="text-label">%</span>';
  document.querySelector('.gauge-fill').setAttribute('stroke-dashoffset', GAUGE_C * (1 - avgAcc / 100));

  document.getElementById('dash-games').textContent = s.totalAnalyzedGames;

  const allRatings = s.ratingOverTime || [];
  const ratings = allRatings.filter(r => {
    const tc = r.timeControl || '';
    const m = tc.match(/^(\d+)/);
    if (!m) return false;
    let base = parseInt(m[1]);
    if (base > 60) base = base / 60;
    return base >= 3 && base < 10; // Blitz only
  });
  if (ratings.length) {
    document.getElementById('dash-rating').textContent = ratings[ratings.length - 1].rating;
  }

  document.getElementById('dash-winrate').textContent = Math.round(s.winRate) + '%';
  document.getElementById('dash-wld').textContent = s.wins + 'W / ' + s.losses + 'L / ' + s.draws + 'D';

  // ── Move Quality Breakdown ──
  const mqOrder = ['book','best','excellent','good','inaccuracy','mistake','blunder'];
  const mqLabels = { book:'', best:'Best', excellent:'Exc', good:'Good', inaccuracy:'', mistake:'', blunder:'' };
  const mqTextClass = { book:'text-white/90', best:'text-white/90', excellent:'text-white/90', good:'text-slate-800/80', inaccuracy:'text-slate-800/80', mistake:'text-white/90', blunder:'text-white/90' };
  const mq = s.moveQualityBreakdown || {};
  const mqTotal = mqOrder.reduce((a,k) => a + (mq[k]||0), 0);

  const barEl = document.getElementById('dash-mqbar');
  const legendEl = document.getElementById('dash-mqlegend');
  barEl.innerHTML = mqOrder.map((k, i) => {
    const pct = mqTotal > 0 ? (mq[k]||0) / mqTotal * 100 : 0;
    if (pct < 0.5) return '';
    const rounded = i === 0 ? 'rounded-l-md' : i === mqOrder.length - 1 ? 'rounded-r-md' : '';
    const label = mqLabels[k] ? mqLabels[k] + ' ' + Math.round(pct) + '%' : Math.round(pct) + '%';
    return `<div class="h-full bg-move-${k} ${rounded} relative" style="width:${pct}%"><div class="absolute inset-0 flex items-center justify-center text-meta font-mono font-semibold ${mqTextClass[k]}">${pct >= 4 ? Math.round(pct) + '%' : ''}</div></div>`;
  }).join('');

  const mqNames = { book:'Book', best:'Best', excellent:'Excellent', good:'Good', inaccuracy:'Inaccuracy', mistake:'Mistake', blunder:'Blunder' };
  legendEl.innerHTML = mqOrder.map(k =>
    `<span class="flex items-center gap-1"><span class="w-1.5 h-1.5 rounded-sm bg-move-${k}"></span>${mqNames[k]}</span>`
  ).join('');

  // ── Charts ──
  const fmtDate = d => new Date(d).toLocaleDateString('en',{month:'short',day:'numeric'});

  // Accuracy Over Time
  new Chart(document.getElementById('accuracyChart'), {
    type: 'line',
    data: { labels: accArr.map(d=>fmtDate(d.date)), datasets: [{ data: accArr.map(d=>d.accuracy), borderColor: T('--chart-accuracy'), fill: false, tension: 0.4, pointRadius: 0, pointHoverRadius: 3, pointHoverBackgroundColor: T('--chart-accuracy'), borderWidth: 1.5 }] },
    options: { responsive: true, maintainAspectRatio: false, scales: { x: {...axisOpts, ticks:{...axisOpts.ticks, maxTicksLimit:5}}, y: {...axisOpts, min:50, max:100} }, interaction:{mode:'index',intersect:false} }
  });

  // Phase
  const phase = s.phaseAccuracyOverTime || [];
  new Chart(document.getElementById('phaseChart'), {
    type: 'line',
    data: { labels: phase.map(d=>fmtDate(d.date)), datasets: [
      { data: phase.map(d=>d.opening), borderColor:T('--chart-opening'), tension:0.4, pointRadius:0, pointHoverRadius:3, borderWidth:1.5 },
      { data: phase.map(d=>d.middlegame), borderColor:T('--chart-middle'), tension:0.4, pointRadius:0, pointHoverRadius:3, borderWidth:1.5 },
      { data: phase.map(d=>d.endgame), borderColor:T('--chart-endgame'), tension:0.4, pointRadius:0, pointHoverRadius:3, borderWidth:1.5 },
    ]},
    options: { responsive:true, maintainAspectRatio:false, scales: { x:{...axisOpts,ticks:{...axisOpts.ticks,maxTicksLimit:5}}, y:{...axisOpts,min:50,max:100} }, interaction:{mode:'index',intersect:false} }
  });

  // Earliest Mistake
  const fm = s.firstInaccuracyOverTime || [];
  if (fm.length) {
    new Chart(document.getElementById('mistakeChart'), {
      type: 'line',
      data: { labels: fm.map(d=>fmtDate(d.date)), datasets: [
        { data: fm.map(d=>d.moveNumber), borderColor:T('--chart-inaccuracy'), tension:0.4, pointRadius:0, pointHoverRadius:3, borderWidth:1.5 },
        { data: fm.map(d=>d.mistakeMoveNumber), borderColor:T('--chart-mistake'), tension:0.4, pointRadius:0, pointHoverRadius:3, borderWidth:1.5 },
        { data: fm.map(d=>d.blunderMoveNumber), borderColor:T('--chart-blunder'), tension:0.4, pointRadius:0, pointHoverRadius:3, borderWidth:1.5 },
      ]},
      options: { responsive:true, maintainAspectRatio:false, scales: { x:{...axisOpts,ticks:{...axisOpts.ticks,maxTicksLimit:5}}, y:{...axisOpts,min:0} }, interaction:{mode:'index',intersect:false} }
    });
  }

  // Rating
  if (ratings.length) {
    new Chart(document.getElementById('ratingChart'), {
      type: 'line',
      data: { labels: ratings.map(d=>fmtDate(d.date)), datasets: [{ data: ratings.map(d=>d.rating), borderColor:T('--chart-rating'), fill:false, tension:0.4, pointRadius:0, pointHoverRadius:3, pointHoverBackgroundColor:T('--chart-rating'), borderWidth:1.5 }] },
      options: { responsive:true, maintainAspectRatio:false, scales: { x:{...axisOpts,ticks:{...axisOpts.ticks,maxTicksLimit:5}}, y:{...axisOpts} }, interaction:{mode:'index',intersect:false} }
    });
  }

  // ── Game lists ──
  const resultLabel = { W:'Won', L:'Lost', D:'Draw' };
  function renderGameList(container, games, good) {
    container.innerHTML = games.map((g, i) => `
      <div class="game-row flex items-center justify-between px-1.5 py-2 rounded-lg min-w-0" onclick="openGame(${g.gameId}, 'dashboard')">
        <div class="flex items-center gap-2 min-w-0">
          <span class="text-label text-muted font-mono w-3 text-right shrink-0">${i+1}</span>
          <div class="min-w-0">
            <div class="flex items-center gap-1">
              <span class="text-body text-white font-medium truncate">vs ${g.opponent}</span>
              ${g.opponentRating ? `<span class="text-meta text-muted font-mono">(${g.opponentRating})</span>` : ''}
            </div>
            <div class="flex items-center gap-1.5 text-meta">
              <span class="${g.result==='W'?'text-good':g.result==='L'?'text-bad':'text-secondary'}">${resultLabel[g.result]||g.result}</span>
              <span class="text-slate-700">&middot;</span>
              <span class="text-secondary">${g.date}</span>
            </div>
          </div>
        </div>
        <span class="text-xs font-bold ${good?'text-good':'text-bad'} font-mono">${g.accuracy}%</span>
      </div>
    `).join('');
  }
  renderGameList(document.getElementById('mostAccurateList'), s.mostAccurateGames || [], true);
  renderGameList(document.getElementById('leastAccurateList'), s.leastAccurateGames || [], false);

  // ── Opening Habits ──
  const prepEl = document.getElementById('deepestPrepList');
  const cleanLines = s.cleanestLines || [];
  const blunders = s.openingBlunders || [];
  // Store for click handlers
  window._cleanLines = cleanLines;
  window._openingBlunders = blunders;

  prepEl.innerHTML = cleanLines.map((c, i) => `
    <div class="game-row flex items-center justify-between px-1.5 py-2 rounded-lg min-w-0" onclick="openOpeningLine('clean', ${i})">
      <div class="flex items-center gap-2 min-w-0">
        <span class="text-label text-muted font-mono w-3 text-right shrink-0">${i+1}</span>
        <div class="min-w-0">
          <div class="text-body text-secondary font-medium truncate">${c.line}</div>
          <div class="text-meta text-muted">${c.color} &middot; ${c.gameCount} game${c.gameCount===1?'':'s'}</div>
        </div>
      </div>
      <span class="text-xs font-bold text-good font-mono">${c.cleanDepth} moves</span>
    </div>
  `).join('');

  const habitsEl = document.getElementById('costliestHabitsList');
  habitsEl.innerHTML = blunders.map((b, i) => {
    const lastSp = b.line.lastIndexOf(' ');
    const prefix = lastSp > 0 ? b.line.slice(0, lastSp) : '';
    const badMove = lastSp > 0 ? b.line.slice(lastSp + 1) : b.line;
    return `
    <div class="game-row flex items-center justify-between px-1.5 py-2 rounded-lg min-w-0" onclick="openOpeningLine('blunder', ${i})">
      <div class="flex items-center gap-2 min-w-0">
        <span class="text-label text-muted font-mono w-3 text-right shrink-0">${i+1}</span>
        <div class="min-w-0">
          <div class="text-body truncate"><span class="text-secondary">${prefix} </span><span class="text-bad font-semibold">${badMove}</span></div>
          <div class="text-meta text-muted">${b.mistakeCount}&times; as ${b.color}</div>
        </div>
      </div>
      <span class="text-xs font-bold text-bad font-mono">-${b.avgCpLoss} cp</span>
    </div>`;
  }).join('');
}

// ══════════════════════════════════════════
// PUZZLES PAGE INIT
// ══════════════════════════════════════════
async function initPuzzles() {
  window._puzzlesInit = true;
  const token = localStorage.getItem('alpine_token');
  if (!token) return;
  const headers = { 'Authorization': 'Bearer ' + token };

  let stats;
  try {
    const res = await fetch(API_URL + '/api/puzzles/stats', { headers });
    if (!res.ok) throw new Error('Failed');
    stats = await res.json();
  } catch (err) {
    document.getElementById('puzzleGauges').innerHTML = '<div class="col-span-3 text-center text-label text-muted py-4">No puzzle data yet. Analyze some games first!</div>';
    return;
  }

  const GAUGE_C = 2 * Math.PI * 50;
  const user = stats.user || {};
  const opp = stats.opponent || {};
  const userRate = Math.round(user.rate || 0);
  const oppRate = Math.round(opp.rate || 0);
  const edge = userRate - oppRate;

  // Gauges
  document.getElementById('puzzleGauges').innerHTML = `
    <div class="flex flex-col items-center">
      <div class="relative w-28 h-28">
        <svg class="gauge-ring w-full h-full" viewBox="0 0 120 120">
          <circle class="gauge-track" cx="60" cy="60" r="50" fill="none" stroke-width="8" />
          <circle class="gauge-fill" cx="60" cy="60" r="50" fill="none"
            stroke="url(#gGlacierPuzzle)" stroke-width="8"
            stroke-dasharray="${GAUGE_C}" stroke-dashoffset="${GAUGE_C * (1 - userRate / 100)}" />
          <defs><linearGradient id="gGlacierPuzzle" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stop-color="var(--good)" /><stop offset="100%" stop-color="var(--accent-bright)" />
          </linearGradient></defs>
        </svg>
        <div class="absolute inset-0 flex flex-col items-center justify-center">
          <span class="text-xl font-bold text-good font-mono">${userRate}%</span>
        </div>
      </div>
      <p class="text-label text-secondary font-medium mt-2">Your Find Rate</p>
      <p class="text-meta text-muted font-mono">${user.found || 0} of ${user.total || 0} found</p>
    </div>
    <div class="flex flex-col items-center">
      <div class="relative w-28 h-28">
        <svg class="gauge-ring w-full h-full" viewBox="0 0 120 120">
          <circle class="gauge-track" cx="60" cy="60" r="50" fill="none" stroke-width="8" />
          <circle class="gauge-fill" cx="60" cy="60" r="50" fill="none"
            stroke="var(--text-dim)" stroke-width="8"
            stroke-dasharray="${GAUGE_C}" stroke-dashoffset="${GAUGE_C * (1 - oppRate / 100)}" />
        </svg>
        <div class="absolute inset-0 flex flex-col items-center justify-center">
          <span class="text-xl font-bold text-secondary font-mono">${oppRate}%</span>
        </div>
      </div>
      <p class="text-label text-secondary font-medium mt-2">Opponent Find Rate</p>
      <p class="text-meta text-muted font-mono">${opp.found || 0} of ${opp.total || 0} found</p>
    </div>
    <div class="flex flex-col items-center justify-center">
      <div class="card-neutral p-5 w-full text-center">
        <p class="text-3xl font-bold ${edge >= 0 ? 'text-good' : 'text-bad'} font-mono leading-none">${edge >= 0 ? '+' : ''}${edge}%</p>
        <p class="text-label text-secondary font-medium mt-2">Tactical Edge</p>
        <p class="text-meta ${edge >= 0 ? 'text-good-dim' : 'text-bad'} mt-1">${edge >= 0 ? 'You outperform your opponents' : 'Opponents have the edge'}</p>
      </div>
    </div>`;

  // Position breakdown
  const positions = stats.byPosition || [];
  const posLabels = { winning: 'Winning Positions', equal: 'Equal Positions', losing: 'Losing Positions' };
  document.getElementById('puzzlePositions').innerHTML = positions.map(p => {
    const uRate = Math.round(p.user?.rate || 0);
    const oRate = Math.round(p.opponent?.rate || 0);
    return `<div>
      <div class="flex items-center justify-between mb-1.5">
        <span class="text-label text-muted">${posLabels[p.position] || p.position}</span>
        <span class="text-meta text-muted font-mono">${p.user?.total || 0} puzzles</span>
      </div>
      <div class="flex items-center gap-2 mb-1">
        <span class="text-meta text-muted w-8">You</span>
        <div class="flex-1 h-3 rounded-full bg-slate-800/60 overflow-hidden"><div class="h-full rounded-full bg-good" style="width:${uRate}%"></div></div>
        <span class="text-meta font-mono text-good w-8 text-right">${uRate}%</span>
      </div>
      <div class="flex items-center gap-2">
        <span class="text-meta text-muted w-8">Opp</span>
        <div class="flex-1 h-3 rounded-full bg-slate-800/60 overflow-hidden"><div class="h-full rounded-full bg-slate-600/80" style="width:${oRate}%"></div></div>
        <span class="text-meta font-mono text-muted w-8 text-right">${oRate}%</span>
      </div>
    </div>`;
  }).join('');

  // Theme tables
  const themes = (stats.byTheme || []).filter(t => (t.user?.total || 0) >= 10 && isVisibleTag(t.theme));
  const alphaSort = (a, b) => tagDisplayName(a.theme).localeCompare(tagDisplayName(b.theme));
  const mateThemes = themes.filter(t => t.theme.toLowerCase().includes('mate')).sort(alphaSort);
  const tacticThemes = themes.filter(t => !t.theme.toLowerCase().includes('mate')).sort(alphaSort);

  function themeTable(title, items) {
    if (items.length === 0) return '';
    const rows = items.slice(0, 8).map((t, i) => {
      const uR = Math.round(t.user?.rate || 0);
      const oR = Math.round(t.opponent?.rate || 0);
      const edge = uR - oR;
      const edgeColor = edge > 0 ? 'text-good' : edge < 0 ? 'text-bad' : 'text-muted';
      return `<div class="grid grid-cols-[1fr_40px_40px_44px_40px] gap-x-2 px-1 py-1.5 text-secondary ${i % 2 === 1 ? 'bg-slate-800/20 rounded' : ''}">
        <span>${tagDisplayName(t.theme)}</span>
        <span class="text-right font-mono text-white">${uR}%</span>
        <span class="text-right font-mono text-muted">${oR}%</span>
        <span class="text-right font-mono ${edgeColor}">${edge > 0 ? '+' : ''}${edge}%</span>
        <span class="text-right font-mono text-muted">${t.user?.total || 0}</span>
      </div>`;
    }).join('');

    return `<div class="card p-4 fade-up">
      <h2 class="text-xs font-semibold text-white mb-3">${title}</h2>
      <div class="text-meta">
        <div class="grid grid-cols-[1fr_40px_40px_44px_40px] gap-x-2 px-1 py-1.5 text-secondary uppercase tracking-wider font-medium border-b border-slate-800/50">
          <span>Theme</span><span class="text-right">You</span><span class="text-right">Opp</span><span class="text-right">Edge</span><span class="text-right">Total</span>
        </div>
        ${rows}
      </div>
    </div>`;
  }

  document.getElementById('puzzleThemeTables').innerHTML =
    themeTable('By Tactic', tacticThemes) + themeTable('By Checkmate Pattern', mateThemes);

  // Now load the actual puzzles for the grid
  await loadPuzzleGrid();
}

// ══════════════════════════════════════════
// PUZZLE BROWSING + SOLVE MODE
// ══════════════════════════════════════════
const PUZZLES_PER_PAGE = 9;
let _allPuzzles = [];
let _puzzleThemes = {};
let _puzzleSelectedTheme = null;
let _puzzlePage = 1;
// Solve mode state
let _solvePuzzle = null;
let _solveGame = null;       // chess.js instance
let _solveMoveIndex = 0;
let _solveStatus = 'solving'; // 'solving' | 'solved' | 'failed'
var _solveCg = null;          // Chessground instance for solve board (var for hoisting)
let _solveShowSolution = false;
let _solveSolverColor = 'white';

async function loadPuzzleGrid(theme) {
  const token = localStorage.getItem('alpine_token');
  if (!token) return;

  let url = API_URL + '/api/puzzles';
  if (theme) url += '?theme=' + encodeURIComponent(theme);

  try {
    const res = await fetch(url, { headers: { 'Authorization': 'Bearer ' + token } });
    if (!res.ok) throw new Error('Failed');
    const data = await res.json();
    _allPuzzles = data.puzzles || [];
    _puzzleThemes = data.themes || {};
  } catch {
    _allPuzzles = [];
    _puzzleThemes = {};
  }

  _puzzlePage = 1;
  renderPuzzleFilters();
  renderPuzzleGrid();
}

function renderPuzzleFilters() {
  const sortedThemes = Object.entries(_puzzleThemes)
    .filter(([t]) => isVisibleTag(t))
    .sort((a, b) => b[1] - a[1])
    .map(([t]) => t);

  if (sortedThemes.length === 0) {
    document.getElementById('puzzleFilters').innerHTML = '';
    return;
  }

  document.getElementById('puzzleFilters').innerHTML = `
    <div class="flex items-center gap-1.5 flex-wrap">
      <span class="text-label text-muted mr-1">Filter:</span>
      ${sortedThemes.map(t => {
        const sel = _puzzleSelectedTheme === t;
        return `<button onclick="selectPuzzleTheme('${t}')"
          class="px-2 py-1 text-meta font-medium rounded-md border transition-colors ${
            sel ? 'bg-accent-dim text-accent border-accent/40' : 'bg-transparent text-secondary border-slate-700 hover:border-slate-500'
          }">${tagDisplayName(t)} <span class="font-mono text-muted">${_puzzleThemes[t]}</span></button>`;
      }).join('')}
    </div>`;
}

function renderPuzzleGrid() {
  const puzzles = _allPuzzles;
  const total = puzzles.length;
  const totalPages = Math.max(1, Math.ceil(total / PUZZLES_PER_PAGE));
  const start = (_puzzlePage - 1) * PUZZLES_PER_PAGE;
  const paginated = puzzles.slice(start, start + PUZZLES_PER_PAGE);

  // Count bar
  const countBar = document.getElementById('puzzleCountBar');
  if (total === 0) {
    countBar.innerHTML = '';
    document.getElementById('puzzleGrid').innerHTML = '';
    document.getElementById('puzzlePagination').innerHTML = '';
    document.getElementById('puzzleEmptyState').classList.remove('hidden');
    document.getElementById('puzzleEmptyState').innerHTML = `
      <div class="card p-8 text-center">
        <div class="w-16 h-16 bg-slate-800 rounded-full flex items-center justify-center mx-auto mb-4">
          <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="var(--text-dim)" stroke-width="1.5"><path d="M12 2C9.5 2 8 3.5 8 5.5c0 1.5.5 2 1 2.5L8 10h8l-1-2c.5-.5 1-1 1-2.5C16 3.5 14.5 2 12 2z"/><rect x="7" y="10" width="10" height="2" rx="0.5"/><path d="M8 12v7a3 3 0 003 3h2a3 3 0 003-3v-7"/></svg>
        </div>
        <h2 class="text-lg font-semibold text-white mb-2">No puzzles yet</h2>
        <p class="text-body text-muted mb-5">Puzzles are automatically extracted when you analyze your games.</p>
        <button onclick="switchPage('games')" class="px-5 py-2.5 rounded-lg font-medium text-white text-body bg-gradient-to-r from-sky-400 to-blue-500 hover:from-sky-300 hover:to-blue-400 shadow-[0_0_12px_rgba(56,189,248,0.3)] transition-all">Go to Games</button>
      </div>`;
    return;
  }

  document.getElementById('puzzleEmptyState').classList.add('hidden');

  countBar.innerHTML = `
    <p class="text-label text-muted">
      <span class="text-white font-mono">${total}</span> puzzles from your games
      ${_puzzleSelectedTheme ? `<span class="text-accent ml-1">— ${tagDisplayName(_puzzleSelectedTheme)} <button onclick="selectPuzzleTheme('${_puzzleSelectedTheme}')" class="ml-1 text-muted hover:text-white transition-colors">&times;</button></span>` : ''}
    </p>
    ${totalPages > 1 ? `<p class="text-label text-muted">Showing ${start + 1}–${Math.min(start + PUZZLES_PER_PAGE, total)}</p>` : ''}`;

  // List (games-page style)
  const grid = document.getElementById('puzzleGrid');
  grid.innerHTML = paginated.map((p, i) => {
    const flip = p.fen.split(' ')[1] === 'w'; // flip if solver is black
    const visibleTags = (p.themes || []).filter(isVisibleTag);
    const solverColor = p.fen.split(' ')[1] === 'w' ? 'Black' : 'White';
    const moveCount = Math.floor(p.moves.length / 2);
    const source = p.source === 'chess_com' ? 'C' : 'L';
    const sourceBg = p.source === 'chess_com' ? 'bg-good/20 text-good' : 'bg-white/20 text-white';
    return `
    <div class="card p-4 cursor-pointer transition-all hover:border-sky-400/40 fade-up" onclick="openPuzzleSolve(${i + start})" style="animation-delay:${0.05 + i * 0.03}s">
      <div class="flex items-center justify-between">
        <div class="flex items-center gap-4">
          <div class="w-48 h-48 rounded overflow-hidden shrink-0">${fenToMiniBoard(p.fen, flip)}</div>
          <div>
            <div class="flex items-center gap-2">
              <span class="w-5 h-5 rounded text-meta font-bold flex items-center justify-center ${sourceBg}">${source}</span>
              <span class="text-sm text-white font-medium">vs ${esc(p.opponent)}</span>
            </div>
            <div class="flex items-center gap-2 flex-wrap mt-1 text-label text-muted">
              <span class="font-medium">${solverColor} to move</span>
              <span class="text-slate-700">&middot;</span>
              <span>${moveCount} move${moveCount !== 1 ? 's' : ''}</span>
              <span class="text-slate-700">&middot;</span>
              <span>as ${esc(p.userColor || 'white')}</span>
              ${visibleTags.slice(0, 3).map(t => `<span class="px-1.5 py-0.5 text-label rounded border text-good whitespace-nowrap" style="border-color:var(--accent-dim)">${tagDisplayName(t)}</span>`).join('')}
              ${visibleTags.length > 3 ? `<span class="px-1.5 py-0.5 text-label rounded text-muted">+${visibleTags.length - 3}</span>` : ''}
            </div>
          </div>
        </div>
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="text-muted shrink-0"><path d="M9 18l6-6-6-6"/></svg>
      </div>
    </div>`;
  }).join('');

  // Pagination
  const pag = document.getElementById('puzzlePagination');
  if (totalPages <= 1) { pag.innerHTML = ''; return; }
  const btnCls = 'px-2 py-1 text-meta text-muted rounded border border-slate-700 hover:border-slate-500 transition-colors';
  const disCls = 'px-2 py-1 text-meta text-muted rounded border border-slate-800 opacity-40 cursor-default';
  pag.innerHTML = `
    <button onclick="puzzleGoPage(1)" class="${_puzzlePage === 1 ? disCls : btnCls}" ${_puzzlePage === 1 ? 'disabled' : ''}>First</button>
    <button onclick="puzzleGoPage(${_puzzlePage - 1})" class="${_puzzlePage === 1 ? disCls : btnCls}" ${_puzzlePage === 1 ? 'disabled' : ''}>Prev</button>
    <span class="px-3 py-1 text-label text-muted font-mono">Page ${_puzzlePage} of ${totalPages}</span>
    <button onclick="puzzleGoPage(${_puzzlePage + 1})" class="${_puzzlePage === totalPages ? disCls : btnCls}" ${_puzzlePage === totalPages ? 'disabled' : ''}>Next</button>
    <button onclick="puzzleGoPage(${totalPages})" class="${_puzzlePage === totalPages ? disCls : btnCls}" ${_puzzlePage === totalPages ? 'disabled' : ''}>Last</button>`;
}

function selectPuzzleTheme(theme) {
  if (_puzzleSelectedTheme === theme) {
    _puzzleSelectedTheme = null;
  } else {
    _puzzleSelectedTheme = theme;
  }
  loadPuzzleGrid(_puzzleSelectedTheme);
}

function puzzleGoPage(p) {
  const totalPages = Math.max(1, Math.ceil(_allPuzzles.length / PUZZLES_PER_PAGE));
  _puzzlePage = Math.max(1, Math.min(totalPages, p));
  renderPuzzleGrid();
}

// ── Puzzle Solve Mode ──
function openPuzzleSolve(idx) {
  const puzzle = _allPuzzles[idx];
  if (!puzzle) return;
  _solvePuzzle = puzzle;
  _solvePuzzleIdx = idx;
  _solveShowSolution = false;
  _solveStatus = 'solving';

  // Solver color: opposite of side to move in FEN (FEN is before opponent's blunder)
  _solveSolverColor = puzzle.fen.split(' ')[1] === 'w' ? 'black' : 'white';

  // Show solve view, hide puzzle list
  document.getElementById('page-puzzles').classList.remove('active');
  document.getElementById('puzzleSolveView').classList.add('active');

  // Populate info panels
  const visibleTags = (puzzle.themes || []).filter(isVisibleTag);
  document.getElementById('puzzleSolveThemes').innerHTML = `
    <h3 class="text-label font-medium text-muted mb-2">Themes</h3>
    <div class="flex flex-wrap gap-2">
      ${visibleTags.map(t => `<span class="px-1.5 py-0.5 text-meta rounded border text-good" style="border-color:var(--accent-dim)">${tagDisplayName(t)}</span>`).join('')}
    </div>`;

  const srcBadge = puzzle.source === 'chess_com'
    ? '<span class="w-4 h-4 rounded flex items-center justify-center text-[9px] font-bold bg-green-600 text-white">C</span>'
    : '<span class="w-4 h-4 rounded flex items-center justify-center text-[9px] font-bold bg-white text-black">L</span>';
  document.getElementById('puzzleSolveSource').innerHTML = `
    <h3 class="text-label font-medium text-muted mb-2">Source Game</h3>
    <button onclick="switchPage('analysis'); loadGameAnalysis(${puzzle.gameId})" class="text-accent hover:text-accent-bright text-label transition-colors">
      vs ${esc(puzzle.opponent)} ${puzzle.date ? `<span class="text-muted ml-2">${esc(puzzle.date)}</span>` : ''}
    </button>
    <div class="flex items-center gap-2 mt-1">
      ${srcBadge}
      <span class="text-meta text-muted capitalize">as ${puzzle.userColor}</span>
    </div>`;

  const moveCount = Math.floor(puzzle.moves.length / 2);
  const solverLabel = _solveSolverColor === 'white' ? 'White' : 'Black';
  document.getElementById('puzzleSolveInfo').innerHTML = `
    <h3 class="text-label font-medium text-muted mb-2">Puzzle Info</h3>
    <p class="text-body text-secondary">${solverLabel} to move — ${moveCount} move${moveCount !== 1 ? 's' : ''} to find</p>`;

  initSolveBoard(puzzle);
}

function closePuzzleSolve() {
  document.getElementById('puzzleSolveView').classList.remove('active');
  document.getElementById('page-puzzles').classList.add('active');
  if (_solveCg) { _solveCg.destroy(); _solveCg = null; }
  _solvePuzzle = null;
  _solveGame = null;
}

function initSolveBoard(puzzle) {
  if (!Chess || !Chessground) {
    setTimeout(() => initSolveBoard(puzzle), 200);
    return;
  }

  _solveGame = new Chess(puzzle.fen);
  _solveMoveIndex = 0;
  _solveStatus = 'solving';
  _solveShowSolution = false;

  setSolveBoard(_solveGame.fen(), _solveSolverColor, false);

  updateSolveActions();
  updateSolveStatus();

  // Auto-play opponent's blunder (first move) after 600ms
  if (puzzle.moves.length > 0) {
    setTimeout(() => {
      const move = uciToChessJs(puzzle.moves[0]);
      try { _solveGame.move(move); } catch { return; }
      _solveMoveIndex = 1;
      setSolveBoard(_solveGame.fen(), _solveSolverColor, true);
      updateSolveStatus();
    }, 600);
  }
}

function setSolveBoard(fen, orientation, movable) {
  const el = document.getElementById('puzzleSolveBoard');
  const turnColor = fen.split(' ')[1] === 'w' ? 'white' : 'black';
  const dests = movable ? getSolveDests() : new Map();
  if (_solveCg) { _solveCg.destroy(); _solveCg = null; }
  el.innerHTML = '';
  _solveCg = Chessground(el, {
    fen, orientation, turnColor,
    viewOnly: false,
    coordinates: true,
    animation: { duration: 250 },
    movable: {
      free: false,
      color: movable ? orientation : undefined,
      dests,
      showDests: true,
      events: { after: (orig, dest) => onSolverMove(orig, dest) },
    },
    draggable: { enabled: true },
  });
}

function getSolveDests() {
  if (!_solveGame) return new Map();
  const dests = new Map();
  for (const m of _solveGame.moves({ verbose: true })) {
    if (!dests.has(m.from)) dests.set(m.from, []);
    dests.get(m.from).push(m.to);
  }
  return dests;
}

function uciToChessJs(uci) {
  return {
    from: uci.slice(0, 2),
    to: uci.slice(2, 4),
    promotion: uci.length === 5 ? uci[4] : undefined,
  };
}

function enableSolverMoves() {
  if (!_solveGame || _solveStatus !== 'solving') return;
  setSolveBoard(_solveGame.fen(), _solveSolverColor, true);
}

function onSolverMove(orig, dest) {
  if (_solveStatus !== 'solving' || _solveMoveIndex >= _solvePuzzle.moves.length) return;

  const expectedUci = _solvePuzzle.moves[_solveMoveIndex];
  const expected = uciToChessJs(expectedUci);

  // Build attempted UCI
  let attemptedUci = orig + dest;
  // Handle promotion
  const piece = _solveGame.get(orig);
  if (expected.promotion) {
    attemptedUci += expected.promotion;
  } else if (piece && piece.type === 'p' && (dest[1] === '8' || dest[1] === '1')) {
    attemptedUci += 'q';
  }

  if (attemptedUci === expectedUci) {
    // Correct!
    const moveObj = { from: orig, to: dest, promotion: expected.promotion || (piece && piece.type === 'p' && (dest[1] === '8' || dest[1] === '1') ? 'q' : undefined) };
    try { _solveGame.move(moveObj); } catch { return; }

    _solveMoveIndex++;
    setSolveBoard(_solveGame.fen(), _solveSolverColor, false);

    // Check if solved
    if (_solveMoveIndex >= _solvePuzzle.moves.length) {
      _solveStatus = 'solved';
      updateSolveStatus();
      updateSolveActions();
      return;
    }

    // Auto-play opponent reply
    setTimeout(() => {
      const oppUci = _solvePuzzle.moves[_solveMoveIndex];
      const oppMove = uciToChessJs(oppUci);
      try { _solveGame.move(oppMove); } catch { return; }
      _solveMoveIndex++;
      setSolveBoard(_solveGame.fen(), _solveSolverColor, false);

      if (_solveMoveIndex >= _solvePuzzle.moves.length) {
        _solveStatus = 'solved';
        updateSolveStatus();
        updateSolveActions();
      } else {
        enableSolverMoves();
        updateSolveStatus();
      }
    }, 400);
  } else {
    // Wrong move - revert
    _solveStatus = 'failed';
    setSolveBoard(_solveGame.fen(), _solveSolverColor, false);
    updateSolveStatus();
    updateSolveActions();
  }
}

function flashSquare(sq, color) {
  // Brief highlight via Chessground drawable shapes
  // Since CG doesn't natively do this well, we'll use the DOM
  const boardEl = document.getElementById('puzzleSolveBoard');
  const flash = document.createElement('div');
  flash.style.cssText = `position:absolute;top:0;left:0;right:0;bottom:0;background:${color};pointer-events:none;z-index:10;opacity:1;transition:opacity 0.6s`;
  // Find the square element
  const cgEl = boardEl.querySelector('cg-board');
  if (cgEl) {
    flash.style.position = 'absolute';
    flash.style.borderRadius = '0';
    cgEl.appendChild(flash);
    requestAnimationFrame(() => { flash.style.opacity = '0'; });
    setTimeout(() => flash.remove(), 700);
  }
}

function updateSolveStatus() {
  const el = document.getElementById('puzzleSolveStatus');
  if (_solveStatus === 'solved') {
    el.innerHTML = '<p class="text-body font-semibold" style="color:var(--good)">Puzzle solved!</p>';
  } else if (_solveStatus === 'failed') {
    el.innerHTML = '<p class="text-body font-semibold" style="color:var(--bad)">Incorrect — puzzle failed</p>';
  } else {
    const remaining = Math.ceil((_solvePuzzle.moves.length - _solveMoveIndex) / 2);
    if (_solveMoveIndex === 0) {
      el.innerHTML = '<p class="text-body text-secondary">Find the best move</p>';
    } else {
      el.innerHTML = `<p class="text-body text-secondary">${remaining} move${remaining !== 1 ? 's' : ''} to find</p>`;
    }
  }
}

function updateSolveActions() {
  const el = document.getElementById('puzzleSolveActions');
  const hasNext = _solvePuzzleIdx < _allPuzzles.length - 1;
  const btnSecondary = 'px-4 py-2 rounded-lg text-label font-medium text-muted border border-slate-700 hover:bg-slate-800 hover:text-white transition-colors';
  const btnPrimary = 'px-4 py-2 rounded-lg font-medium text-white text-body bg-gradient-to-r from-sky-400 to-blue-500 hover:from-sky-300 hover:to-blue-400 shadow-[0_0_12px_rgba(56,189,248,0.3)] transition-all';
  let html = '';

  if (_solveStatus === 'solving' && !_solveShowSolution) {
    html += `<button onclick="showPuzzleSolution()" class="${btnSecondary}">Show Solution</button>`;
  }
  if (_solveStatus === 'failed' || _solveStatus === 'solved') {
    html += `<button onclick="retryPuzzleSolve()" class="${btnSecondary}">Retry Puzzle</button>`;
  }
  if (_solveStatus === 'failed' && !_solveShowSolution) {
    html += `<button onclick="showPuzzleSolution()" class="${btnSecondary}">Show Solution</button>`;
  }
  if (hasNext) {
    html += `<button onclick="nextPuzzleSolve()" class="${btnPrimary}">Next Puzzle</button>`;
  }

  el.innerHTML = html;
}

function showPuzzleSolution() {
  _solveShowSolution = true;
  if (_solveCg && _solveMoveIndex < _solvePuzzle.moves.length) {
    const m = _solvePuzzle.moves[_solveMoveIndex];
    _solveCg.set({
      drawable: {
        autoShapes: [{
          orig: m.slice(0, 2),
          dest: m.slice(2, 4),
          brush: 'green',
        }],
      },
    });
  }
  updateSolveActions();
}

function retryPuzzleSolve() {
  if (_solvePuzzle) initSolveBoard(_solvePuzzle);
}

function nextPuzzleSolve() {
  const nextIdx = _solvePuzzleIdx + 1;
  if (nextIdx < _allPuzzles.length) {
    if (_solveCg) { _solveCg.destroy(); _solveCg = null; }
    openPuzzleSolve(nextIdx);
  }
}

let _solvePuzzleIdx = 0;

// ══════════════════════════════════════════
// ENDGAMES PAGE INIT
// ══════════════════════════════════════════
async function initEndgames() {
  window._endgamesInit = true;
  const token = localStorage.getItem('alpine_token');
  if (!token) return;

  let data;
  try {
    const res = await fetch(API_URL + '/api/games/endgame-stats', { headers: { 'Authorization': 'Bearer ' + token } });
    if (!res.ok) throw new Error('Failed');
    data = await res.json();
  } catch (err) {
    document.getElementById('endgameTableBody').innerHTML = '<tr><td colspan="5" class="text-center py-6 text-label text-muted">No endgame data yet. Analyze some games first!</td></tr>';
    return;
  }

  const stats = (data.typeStats || []).sort((a, b) => {
    const edgeA = a.opponentAvgCpLoss - a.userAvgCpLoss;
    const edgeB = b.opponentAvgCpLoss - b.userAvgCpLoss;
    return edgeB - edgeA;
  });

  if (stats.length === 0) {
    document.getElementById('endgameTableBody').innerHTML = '<tr><td colspan="5" class="text-center py-6 text-label text-muted">No endgame data yet.</td></tr>';
    return;
  }

  const tbody = document.getElementById('endgameTableBody');
  tbody.innerHTML = stats.map((s, i) => {
    const edge = s.opponentAvgCpLoss - s.userAvgCpLoss;
    const edgeColor = Math.abs(edge) < 0.5 ? 'text-muted' : edge > 0 ? 'text-good' : 'text-bad';
    return `
      <tr class="border-t border-slate-800/50 ${i % 2 === 1 ? 'bg-slate-800/20' : ''}">
        <td class="py-2.5 pr-4 text-white font-medium">${s.type}</td>
        <td class="py-2.5 px-3 text-right font-mono text-white">${s.userAvgCpLoss.toFixed(1)}</td>
        <td class="py-2.5 px-3 text-right font-mono text-muted">${s.opponentAvgCpLoss.toFixed(1)}</td>
        <td class="py-2.5 px-3 text-right font-mono font-semibold ${edgeColor}">${edge > 0 ? '+' : ''}${edge.toFixed(1)}</td>
        <td class="py-2.5 pl-3 text-right font-mono text-muted">${s.games}</td>
      </tr>`;
  }).join('');
}

// ══════════════════════════════════════════
// TRAINER PAGE INIT
// ══════════════════════════════════════════
const PIECE_URL = 'https://lichess1.org/assets/piece/cburnett/';
const fenPieceMap = {
  K:'wK', Q:'wQ', R:'wR', B:'wB', N:'wN', P:'wP',
  k:'bK', q:'bQ', r:'bR', b:'bB', n:'bN', p:'bP',
};

function fenToMiniBoard(fen, flip) {
  let html = '<div class="mini-board grid grid-cols-8 aspect-square rounded overflow-hidden">';
  let rows = fen.split(' ')[0].split('/');
  if (flip) rows = rows.reverse().map(r => r.split('').reverse().join(''));
  rows.forEach((row, ri) => {
    let ci = 0;
    for (const ch of row) {
      if (ch >= '1' && ch <= '8') {
        for (let e = 0; e < parseInt(ch); e++) {
          const light = (ri + ci) % 2 === 0;
          html += `<div class="${light ? 'sq-light' : 'sq-dark'}"></div>`;
          ci++;
        }
      } else {
        const light = (ri + ci) % 2 === 0;
        const piece = fenPieceMap[ch];
        html += `<div class="${light ? 'sq-light' : 'sq-dark'} sq-piece"><img src="${PIECE_URL}${piece}.svg" alt="${ch}"></div>`;
        ci++;
      }
    }
  });
  return html + '</div>';
}

// Replay SAN moves to get final FEN (same logic as React MiniChessBoard)
function getFinalFen(moves) {
  if (!Chess || !moves || moves.length === 0) return null;
  try {
    const g = new Chess();
    for (const m of moves) {
      const clean = m.replace(/^\d+\.+\s*/, '').replace(/[!?]+$/, '').trim();
      if (clean && clean !== '1-0' && clean !== '0-1' && clean !== '1/2-1/2') {
        g.move(clean);
      }
    }
    return g.fen();
  } catch { return null; }
}

async function initTrainer() {
  window._trainerInit = true;
  const token = localStorage.getItem('alpine_token');
  if (!token) return;

  let openings;
  try {
    const res = await fetch(API_URL + '/api/trainer/openings', { headers: { 'Authorization': 'Bearer ' + token } });
    if (!res.ok) throw new Error('Failed');
    openings = await res.json();
  } catch (err) {
    document.getElementById('trainerGrid').innerHTML = '<div class="col-span-3 text-center text-label text-muted py-8">No trainer openings available yet.</div>';
    return;
  }

  if (!openings || openings.length === 0) {
    document.getElementById('trainerGrid').innerHTML = '<div class="col-span-3 text-center text-label text-muted py-8">No trainer openings available yet.</div>';
    return;
  }

  const grid = document.getElementById('trainerGrid');
  grid.innerHTML = openings.map(o => {
    const pct = o.puzzle_count > 0 ? Math.round((o.completed_count / o.puzzle_count) * 100) : 0;
    const done = pct === 100;
    const boardHtml = o.sample_fen ? fenToMiniBoard(o.sample_fen) : '<div class="aspect-square bg-slate-900/50 rounded"></div>';

    return `
    <div class="card p-0 cursor-pointer transition-all hover:border-sky-400/40 group" style="border-radius:10px" onclick="openTrainerOpening('${o.opening_name.replace(/'/g, "\\'")}')">
      ${boardHtml}
      <div class="p-3">
        <div class="flex items-center gap-1.5 mb-0.5">
          <span class="text-body text-white font-medium group-hover:text-white transition-colors">${o.opening_name}</span>
          ${done ? '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="var(--good)" stroke-width="2.5" stroke-linecap="round"><path d="M5 13l4 4L19 7"/></svg>' : ''}
        </div>
        <div class="flex items-center justify-between mb-1.5">
          <span class="text-meta text-muted">${o.completed_count}/${o.puzzle_count} completed</span>
          <span class="text-meta font-mono ${done ? 'text-good' : 'text-muted'}">${pct}%</span>
        </div>
        <div class="h-1.5 rounded-full bg-slate-800/60 overflow-hidden">
          <div class="h-full rounded-full transition-all" style="width:${pct}%; background: ${done ? 'var(--good)' : 'var(--accent)'}"></div>
        </div>
      </div>
    </div>`;
  }).join('');
}

// ══════════════════════════════════════════
// TRAINER DRILL ENGINE
// ══════════════════════════════════════════
let _trainerPuzzles = [];
let _trainerCompletedIds = new Set();
let _trainerPuzzleIdx = 0;
let _trainerNode = null;
let _trainerGame = null;
let _trainerCgInstance = null;
let _trainerPhase = 'idle';
let _trainerSolverColor = 'white';
let _trainerMoveHistory = [];
let _trainerHadMistake = false;
let _trainerOpeningName = '';
// Variation drilling state
let _trainerVisitedLeaves = new Set();
let _trainerDrillMode = 'main'; // 'main' | 'deep'
let _trainerTotalLeaves = 1;
let _trainerVariationsCompleted = 0;
let _trainerIsFirstAttempt = true;
let _trainerOpponentOrder = new Map();
let _trainerRestartTimer = null;

// ── Tree utility functions (match React TrainerBoard.tsx) ──

/** Count all variations (leaf paths). Opponent=sum children, Solver=max accepted. */
function countLeaves(node) {
  if (node.type === 'cutoff' || node.type === 'terminal') return 1;
  if (!node.moves) return 1;
  const entries = Object.values(node.moves);
  if (entries.length === 0) return 1;
  if (node.type === 'opponent') {
    let total = 0;
    for (const m of entries) { if (m.result) total += countLeaves(m.result); }
    return total || 1;
  }
  let best = 0;
  for (const m of entries) {
    if (!m.accepted) continue;
    const n = m.result ? countLeaves(m.result) : 1;
    if (n > best) best = n;
  }
  return best || 1;
}

/** Count variations following only the main line (best opponent move at each node) */
function countMainLineLeaves(node) {
  if (node.type === 'cutoff' || node.type === 'terminal') return 1;
  if (!node.moves) return 1;
  const entries = Object.values(node.moves);
  if (entries.length === 0) return 1;
  if (node.type === 'opponent') {
    const computed = entries.filter(m => m.result);
    if (computed.length === 0) return 1;
    const best = computed.reduce((a, b) => ((a.games ?? 0) >= (b.games ?? 0) ? a : b));
    return best.result ? countMainLineLeaves(best.result) : 1;
  }
  let best = 0;
  for (const m of entries) {
    if (!m.accepted) continue;
    const n = m.result ? countMainLineLeaves(m.result) : 1;
    if (n > best) best = n;
  }
  return best || 1;
}

/** Check if tree has opponent nodes with more than one computed move */
function treeHasDeepVariations(node) {
  if (node.type === 'cutoff' || node.type === 'terminal' || !node.moves) return false;
  const entries = Object.entries(node.moves);
  if (node.type === 'opponent') {
    const computed = entries.filter(([, m]) => m.result);
    if (computed.length > 1) return true;
    for (const [, m] of computed) {
      if (m.result && treeHasDeepVariations(m.result)) return true;
    }
    return false;
  }
  for (const [, m] of entries) {
    if (!m.accepted) continue;
    if (m.result && treeHasDeepVariations(m.result)) return true;
  }
  return false;
}

/** Check if a subtree has any unvisited leaf nodes */
function hasUnvisitedLeaves(node, visited) {
  if (node.type === 'cutoff' || node.type === 'terminal' || !node.moves) {
    return !visited.has(node);
  }
  const entries = Object.values(node.moves);
  if (entries.length === 0) return !visited.has(node);
  if (node.type === 'opponent') {
    for (const m of entries) {
      if (m.result && hasUnvisitedLeaves(m.result, visited)) return true;
    }
    return false;
  }
  for (const m of entries) {
    if (!m.accepted) continue;
    if (!m.result) { if (!visited.has(node)) return true; continue; }
    if (hasUnvisitedLeaves(m.result, visited)) return true;
  }
  return false;
}

/** Mark all direct cutoff/terminal results of accepted moves at a solver node as visited */
function markSiblingLeaves(solverNode, visited) {
  if (!solverNode.moves) return;
  for (const m of Object.values(solverNode.moves)) {
    if (!m.accepted) continue;
    if (m.result && (m.result.type === 'cutoff' || m.result.type === 'terminal')) {
      visited.add(m.result);
    }
    if (!m.result) visited.add(solverNode);
  }
}

function setTrainerStatus(title, msg, type) {
  // type: 'success' | 'error' | 'info'
  const titleEl = document.getElementById('trainerStatusTitle');
  const msgEl = document.getElementById('trainerStatusMsg');
  titleEl.textContent = title;
  msgEl.textContent = msg || '';
  titleEl.className = 'text-sm font-semibold' + (
    type === 'success' ? ' text-good' :
    type === 'error' ? ' text-bad' :
    ' text-slate-300'
  );
}

function setTrainerBoard(fen, orientation, movable) {
  if (!Chessground) return;
  const el = document.getElementById('trainerBoard');
  const dests = movable ? getTrainerDests() : new Map();
  const turnColor = fen.split(' ')[1] === 'w' ? 'white' : 'black';
  // Always recreate to ensure events are bound correctly
  if (_trainerCgInstance) { _trainerCgInstance.destroy(); _trainerCgInstance = null; }
  el.innerHTML = '';
  _trainerCgInstance = Chessground(el, {
    fen, orientation, turnColor,
    viewOnly: false,
    coordinates: true,
    animation: { duration: 250 },
    movable: {
      free: false,
      color: movable ? turnColor : undefined,
      dests,
      showDests: true,
      events: { after: (orig, dest) => trainerOnMove(orig, dest) },
    },
    draggable: { enabled: true },
  });
  setTimeout(resizeBoards, 50);
}

function getTrainerDests() {
  if (!_trainerGame) return new Map();
  const dests = new Map();
  for (const m of _trainerGame.moves({ verbose: true })) {
    if (!dests.has(m.from)) dests.set(m.from, []);
    dests.get(m.from).push(m.to);
  }
  return dests;
}

async function openTrainerOpening(name) {
  _trainerOpeningName = name;
  const token = localStorage.getItem('alpine_token');
  if (!token || !Chess) return;

  document.getElementById('trainerSelectView').style.display = 'none';
  document.getElementById('trainerDrillView').style.display = '';
  setTrainerStatus('Loading puzzles...', '', 'info');
  document.getElementById('trainerMoveList').innerHTML = '';

  try {
    const res = await fetch(API_URL + '/api/trainer/puzzles?opening=' + encodeURIComponent(name), {
      headers: { 'Authorization': 'Bearer ' + token },
    });
    if (!res.ok) throw new Error('Failed to load puzzles');
    const data = await res.json();
    _trainerPuzzles = data.puzzles || [];
    _trainerCompletedIds = new Set(data.completed_ids || []);
  } catch (err) {
    setTrainerStatus('Error', err.message, 'error');
    return;
  }

  if (_trainerPuzzles.length === 0) {
    setTrainerStatus('No puzzles', 'No puzzles available for this opening.', 'info');
    return;
  }

  _trainerPuzzleIdx = _trainerPuzzles.findIndex(p => !_trainerCompletedIds.has(p.id));
  if (_trainerPuzzleIdx < 0) _trainerPuzzleIdx = 0;

  resetTrainerVariationState();
  updateTrainerProgress();
  startTrainerPuzzle();
}

function exitTrainerDrill() {
  document.getElementById('trainerDrillView').style.display = 'none';
  document.getElementById('trainerSelectView').style.display = '';
  _trainerPhase = 'idle';
  window._trainerInit = false;
  initTrainer();
}

function updateTrainerProgress() {
  const total = _trainerPuzzles.length;
  const done = _trainerCompletedIds.size;
  const pct = total > 0 ? Math.round((done / total) * 100) : 0;
  document.getElementById('trainerProgressLabel').textContent = `${done}/${total} completed`;
  document.getElementById('trainerProgressPct').textContent = `${pct}%`;
  document.getElementById('trainerProgressBar').style.width = `${pct}%`;
  document.getElementById('trainerDrillCounter').textContent = `${_trainerOpeningName} — Puzzle ${_trainerPuzzleIdx + 1} / ${total}`;
}

function startTrainerPuzzle(fast) {
  const puzzle = _trainerPuzzles[_trainerPuzzleIdx];
  if (!puzzle) return;

  const isFast = fast || !_trainerIsFirstAttempt;
  _trainerSolverColor = puzzle.solver_color === 'w' ? 'white' : 'black';
  _trainerMoveHistory = [];
  _trainerPhase = 'show_mistake';

  _trainerGame = new Chess(puzzle.pre_mistake_fen);
  setTrainerBoard(puzzle.pre_mistake_fen, _trainerSolverColor, false);
  renderTrainerMoves();
  updateTrainerProgress();
  updateTrainerButtons();

  if (!isFast) {
    setTrainerStatus('Watch...', 'Your opponent is about to blunder.', 'info');
  } else {
    setTrainerStatus('Next variation', `Opponent plays ${puzzle.mistake_san}...`, 'info');
  }

  const delay = isFast ? 300 : 1000;
  setTimeout(() => {
    if (_trainerPhase !== 'show_mistake') return;
    const uci = puzzle.mistake_uci;
    const moveResult = _trainerGame.move({ from: uci.slice(0, 2), to: uci.slice(2, 4), promotion: uci[4] || undefined });
    if (moveResult) {
      _trainerMoveHistory.push({ san: moveResult.san, type: 'mistake' });
      renderTrainerMoves();
    }
    _trainerNode = puzzle.tree;
    setTrainerBoard(_trainerGame.fen(), _trainerSolverColor, true);
    _trainerPhase = 'solver_turn';
    setTrainerStatus('Punish the mistake!', `They played ${puzzle.mistake_san}. Find the best response!`, 'info');
    _trainerIsFirstAttempt = false;
  }, delay);
}

function trainerOnMove(orig, dest) {
  if (_trainerPhase !== 'solver_turn' || !_trainerNode || !_trainerNode.moves) return;

  let uci = orig + dest;
  let moveData = _trainerNode.moves[uci];
  let promoChar = '';
  if (!moveData) {
    for (const p of ['q', 'r', 'b', 'n']) {
      if (_trainerNode.moves[uci + p]) { moveData = _trainerNode.moves[uci + p]; promoChar = p; break; }
    }
  }

  if (!moveData || !moveData.accepted) {
    // Wrong move — Chessground already moved the piece visually
    _trainerHadMistake = true;
    _trainerPhase = 'showing_correction';

    // Reset board to actual position (undo visual move)
    setTrainerBoard(_trainerGame.fen(), _trainerSolverColor, false);
    setTrainerStatus('Wrong move', 'That\'s not the best response.', 'error');

    setTimeout(() => {
      if (_trainerPhase !== 'showing_correction') return;
      // Show the best accepted move on the board
      const bestUci = Object.keys(_trainerNode.moves).find(k => _trainerNode.moves[k].accepted);
      if (bestUci) {
        const bestData = _trainerNode.moves[bestUci];
        const showGame = new Chess(_trainerGame.fen());
        try {
          showGame.move({ from: bestUci.slice(0, 2), to: bestUci.slice(2, 4), promotion: bestUci[4] || undefined });
          setTrainerBoard(showGame.fen(), _trainerSolverColor, false);
        } catch {}
        setTrainerStatus('Wrong move', `The best move was ${bestData.san}. Now play it.`, 'error');
      }

      // Reset back so user can play the correct move
      setTimeout(() => {
        if (_trainerPhase !== 'showing_correction') return;
        _trainerPhase = 'solver_turn';
        setTrainerBoard(_trainerGame.fen(), _trainerSolverColor, true);
        setTrainerStatus('Try again', 'Play the correct move.', 'info');
        updateTrainerButtons();
      }, 1500);
    }, 800);
    return;
  }

  // Correct move — apply to chess.js game state
  const moveResult = _trainerGame.move({ from: orig, to: dest, promotion: promoChar || undefined });
  if (!moveResult) { setTrainerBoard(_trainerGame.fen(), _trainerSolverColor, true); return; }

  _trainerMoveHistory.push({ san: moveResult.san, type: 'solver' });
  renderTrainerMoves();
  setTrainerBoard(_trainerGame.fen(), _trainerSolverColor, false);
  const accepted = Object.values(_trainerNode.moves).filter(m => m.accepted);
  if (accepted.length === 1) {
    setTrainerStatus('Correct!', `${moveResult.san} — the only winning move.`, 'success');
  } else {
    const others = accepted.filter(m => m.san !== moveResult.san).map(m => m.san).join(', ');
    setTrainerStatus('Correct!', `${moveResult.san} — correct!${others ? ' Also good: ' + others : ''}`, 'success');
  }

  const nextNode = moveData.result;
  if (!nextNode || nextNode.type === 'cutoff') {
    markSiblingLeaves(_trainerNode, _trainerVisitedLeaves);
    setTimeout(() => trainerPuzzleComplete(nextNode ?? _trainerNode, 'Position won! Advantage secured.'), 500);
    return;
  }
  if (nextNode.type === 'terminal') {
    markSiblingLeaves(_trainerNode, _trainerVisitedLeaves);
    setTimeout(() => trainerPuzzleComplete(nextNode, 'Checkmate! Brilliant!'), 500);
    return;
  }

  if (nextNode.type === 'opponent') {
    _trainerPhase = 'opponent_thinking';
    playTrainerOpponentMove(nextNode);
  } else {
    _trainerNode = nextNode;
    _trainerPhase = 'solver_turn';
    setTrainerBoard(_trainerGame.fen(), _trainerSolverColor, true);
    setTrainerStatus('Your turn', 'Find the best move.', 'info');
    updateTrainerButtons();
  }
}

function playTrainerOpponentMove(node) {
  if (!node.moves) { trainerPuzzleComplete(node, 'Position won!'); return; }
  const computed = Object.entries(node.moves).filter(([, m]) => m.result);
  if (computed.length === 0) { trainerPuzzleComplete(node, 'Position won!'); return; }

  let pick;
  if (_trainerDrillMode === 'main') {
    // Main line: always pick the most popular move
    pick = computed.reduce((a, b) => ((a[1].games ?? 0) >= (b[1].games ?? 0) ? a : b));
  } else {
    // Deep mode: shuffled order, prefer unvisited branches
    let order = _trainerOpponentOrder.get(node);
    if (!order) {
      order = Object.keys(node.moves).slice();
      for (let i = order.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [order[i], order[j]] = [order[j], order[i]];
      }
      _trainerOpponentOrder.set(node, order);
    }
    const computedSet = new Set(computed.map(([u]) => u));
    pick = order
      .filter(u => computedSet.has(u))
      .map(u => [u, node.moves[u]])
      .find(([, m]) => hasUnvisitedLeaves(m.result, _trainerVisitedLeaves))
      ?? computed[0];
  }

  const [uci, moveData] = pick;

  setTimeout(() => {
    const moveResult = _trainerGame.move({ from: uci.slice(0, 2), to: uci.slice(2, 4), promotion: uci[4] || undefined });
    if (!moveResult) { trainerPuzzleComplete(node, 'Position won!'); return; }

    _trainerMoveHistory.push({ san: moveResult.san, type: 'opponent' });
    renderTrainerMoves();

    const result = moveData.result;
    if (result.type === 'cutoff') {
      trainerPuzzleComplete(result, `Opponent played ${moveData.san}. Advantage secured!`);
      return;
    }
    if (result.type === 'terminal') {
      trainerPuzzleComplete(result, `Opponent played ${moveData.san}. Game over!`);
      return;
    }

    _trainerNode = result;
    _trainerPhase = 'solver_turn';
    setTrainerBoard(_trainerGame.fen(), _trainerSolverColor, true);
    const gamesNote = moveData.games && moveData.games > 0 ? ` (${moveData.games} games)` : ' (engine)';
    setTrainerStatus('Your turn', `Opponent played ${moveData.san}${gamesNote}. Find the best response.`, 'info');
    updateTrainerButtons();
  }, 700);
}

function trainerPuzzleComplete(leaf, message) {
  const puzzle = _trainerPuzzles[_trainerPuzzleIdx];

  // Mark this leaf as visited
  if (leaf) _trainerVisitedLeaves.add(leaf);
  const completed = _trainerVisitedLeaves.size;
  const total = _trainerTotalLeaves;
  const clamped = Math.min(completed, total);
  _trainerVariationsCompleted = clamped;

  if (clamped >= total) {
    // All variations done — but if user made mistakes, replay the whole thing
    if (_trainerHadMistake) {
      _trainerPhase = 'done';
      setTrainerBoard(_trainerGame.fen(), _trainerSolverColor, false);
      setTrainerStatus('Good, but not perfect', 'You made mistakes along the way. Let\'s try it again from the top.', 'info');
      _trainerHadMistake = false;
      _trainerVisitedLeaves.clear();
      _trainerOpponentOrder.clear();
      _trainerVariationsCompleted = 0;
      clearTimeout(_trainerRestartTimer);
      // Quick restart: skip the mistake animation, jump straight to solver's turn
      _trainerRestartTimer = setTimeout(() => {
        _trainerGame = new Chess(puzzle.tree.fen);
        _trainerMoveHistory = [{ san: puzzle.mistake_san, type: 'mistake' }];
        renderTrainerMoves();
        _trainerNode = puzzle.tree;
        setTrainerBoard(_trainerGame.fen(), _trainerSolverColor, true);
        _trainerPhase = 'solver_turn';
        setTrainerStatus('Try again from the top', `They played ${puzzle.mistake_san}. Find the best response!`, 'info');
        updateTrainerButtons();
      }, 1000);
      updateTrainerButtons();
      return;
    }

    // Truly done — fire completion
    _trainerPhase = 'done';
    setTrainerBoard(_trainerGame.fen(), _trainerSolverColor, false);

    if (_trainerDrillMode === 'main') {
      // Mark puzzle complete on main line finish
      if (puzzle && !_trainerCompletedIds.has(puzzle.id)) {
        _trainerCompletedIds.add(puzzle.id);
        updateTrainerProgress();
        const token = localStorage.getItem('alpine_token');
        if (token) {
          fetch(API_URL + '/api/trainer/progress', {
            method: 'POST',
            headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json' },
            body: JSON.stringify({ puzzle_id: puzzle.id }),
          }).catch(() => {});
        }
      }
    }

    const doneMsg = _trainerDrillMode === 'main' ? 'Main line complete!' : `Completed all ${total} variation${total !== 1 ? 's' : ''}.`;
    setTrainerStatus(doneMsg, message || 'Well done!', 'success');
    updateTrainerButtons();
  } else {
    // More variations remain — show status, then auto-restart
    _trainerPhase = 'done';
    setTrainerBoard(_trainerGame.fen(), _trainerSolverColor, false);
    setTrainerStatus(`Variation ${clamped}/${total} complete!`, message || '', 'success');
    clearTimeout(_trainerRestartTimer);
    _trainerRestartTimer = setTimeout(() => startTrainerPuzzle(true), 1500);
    updateTrainerButtons();
  }
}

function renderTrainerMoves() {
  const ml = document.getElementById('trainerMoveList');
  const puzzle = _trainerPuzzles[_trainerPuzzleIdx];
  if (!puzzle) { ml.innerHTML = ''; return; }

  const parts = puzzle.pre_mistake_fen.split(' ');
  const turnAtMistake = parts[1]; // 'w' or 'b'
  let startMoveNum = parseInt(parts[5]) || 1;

  let html = '';
  for (let i = 0; i < _trainerMoveHistory.length; i++) {
    const m = _trainerMoveHistory[i];
    const cls = m.type === 'mistake' ? 'text-bad' : m.type === 'solver' ? 'text-good' : 'text-move-inaccuracy';
    const isWhite = (turnAtMistake === 'w') ? (i % 2 === 0) : (i % 2 === 1);
    const mn = startMoveNum + Math.floor((i + (turnAtMistake === 'b' ? 1 : 0)) / 2);

    if (isWhite) html += `<span class="text-secondary mr-1">${mn}.</span>`;
    else if (i === 0) html += `<span class="text-secondary mr-1">${mn}...</span>`;
    html += `<span class="${cls} font-semibold">${m.san}</span> `;
  }
  ml.innerHTML = html;
  ml.scrollTop = ml.scrollHeight;
}

function trainerHint() {
  if (_trainerPhase !== 'solver_turn' || !_trainerNode || !_trainerNode.moves) return;
  const bestUci = Object.keys(_trainerNode.moves).find(k => _trainerNode.moves[k].accepted);
  if (bestUci) {
    setTrainerStatus('Hint', `Try moving the piece on ${bestUci.slice(0, 2)}.`, 'info');
  }
}

function trainerRetry() {
  resetTrainerVariationState();
  startTrainerPuzzle();
}

function trainerNext() {
  let next = -1;
  for (let i = _trainerPuzzleIdx + 1; i < _trainerPuzzles.length; i++) {
    if (!_trainerCompletedIds.has(_trainerPuzzles[i].id)) { next = i; break; }
  }
  if (next < 0) {
    for (let i = 0; i < _trainerPuzzleIdx; i++) {
      if (!_trainerCompletedIds.has(_trainerPuzzles[i].id)) { next = i; break; }
    }
  }
  if (next < 0) next = (_trainerPuzzleIdx + 1) % _trainerPuzzles.length;
  _trainerPuzzleIdx = next;
  resetTrainerVariationState();
  startTrainerPuzzle();
}

function resetTrainerVariationState() {
  clearTimeout(_trainerRestartTimer);
  _trainerHadMistake = false;
  _trainerVisitedLeaves.clear();
  _trainerOpponentOrder.clear();
  _trainerDrillMode = 'main';
  const puzzle = _trainerPuzzles[_trainerPuzzleIdx];
  _trainerTotalLeaves = puzzle ? countMainLineLeaves(puzzle.tree) : 1;
  _trainerVariationsCompleted = 0;
  _trainerIsFirstAttempt = true;
}

function startDeepDrill() {
  const puzzle = _trainerPuzzles[_trainerPuzzleIdx];
  if (!puzzle) return;
  _trainerVisitedLeaves.clear();
  _trainerOpponentOrder.clear();
  _trainerDrillMode = 'deep';
  _trainerTotalLeaves = countLeaves(puzzle.tree);
  _trainerVariationsCompleted = 0;
  _trainerIsFirstAttempt = true;
  _trainerHadMistake = false;
  setTimeout(() => startTrainerPuzzle(), 300);
}

function updateTrainerButtons() {
  const puzzle = _trainerPuzzles[_trainerPuzzleIdx];
  const allDone = _trainerVariationsCompleted >= _trainerTotalLeaves;
  const hasNext = _trainerPuzzles.length > 1;

  // Hint: only during solver_turn
  document.getElementById('btnTrainerHint').style.display = _trainerPhase === 'solver_turn' ? '' : 'none';
  // Retry: only when fully done
  document.getElementById('btnTrainerRetry').style.display = (_trainerPhase === 'done' && allDone) ? '' : 'none';
  // Next: only when fully done and has more puzzles
  document.getElementById('btnTrainerNext').style.display = (_trainerPhase === 'done' && allDone && hasNext) ? '' : 'none';

  // Drill Deeper: only when main line done and tree has deep variations
  const deepBtn = document.getElementById('btnTrainerDeepDrill');
  if (deepBtn) {
    const showDeep = _trainerPhase === 'done' && allDone && _trainerDrillMode === 'main' && puzzle && treeHasDeepVariations(puzzle.tree);
    deepBtn.style.display = showDeep ? '' : 'none';
    if (showDeep) {
      deepBtn.textContent = `Drill Deeper (${countLeaves(puzzle.tree)} variations)`;
    }
  }

  // Variation counter
  const varCounter = document.getElementById('trainerVarCounter');
  if (varCounter) {
    if (_trainerDrillMode === 'deep' && _trainerTotalLeaves > 1) {
      const current = Math.min(_trainerVariationsCompleted + (_trainerPhase !== 'done' && _trainerPhase !== 'idle' ? 1 : 0), _trainerTotalLeaves);
      varCounter.textContent = `Variation ${current} / ${_trainerTotalLeaves}`;
      varCounter.style.display = '';
    } else if (_trainerDrillMode === 'main') {
      varCounter.textContent = 'Main line';
      varCounter.style.display = '';
    } else {
      varCounter.style.display = 'none';
    }
  }
}

// ══════════════════════════════════════════
// GAMES LIST PAGE
// ══════════════════════════════════════════
const GAMES_PER_PAGE = 10;
let _gamesPage = 1;
let _gamesTotal = 0;
let _gamesSelectedTags = new Set();
let _gamesHasMoreHistory = false;
let _gamesTotalUnanalyzed = 0;
let _gamesTotalAnalyzed = 0;
let _gamesAllTags = {};
let _gamesCache = {}; // id -> game object (with SAN moves from stored endpoint)

// Tag display names
const TAG_DISPLAY = {
  // Game-level tags
  queen_sacrifice:'Queen Sacrifice', rook_sacrifice:'Rook Sacrifice', smothered_mate:'Smothered Mate',
  titled:'Titled', GM:'GM', IM:'IM', FM:'FM', CM:'CM', NM:'NM',
  WGM:'WGM', WIM:'WIM', WFM:'WFM', WCM:'WCM', WNM:'WNM',
  'Chess.com':'Chess.com', 'Lichess':'Lichess',
  Win:'Win', Loss:'Loss', Draw:'Draw',
  // Tactic themes
  fork:'Fork', pin:'Pin', skewer:'Skewer', deflection:'Deflection',
  attraction:'Attraction', interference:'Interference', intermezzo:'Intermezzo',
  clearance:'Clearance', discoveredAttack:'Discovered Attack',
  discoveredCheck:'Discovered Check', doubleCheck:'Double Check',
  xRayAttack:'X-Ray Attack', windmill:'Windmill', sacrifice:'Sacrifice',
  capturingDefender:'Capturing Defender', hangingPiece:'Hanging Piece',
  trappedPiece:'Trapped Piece', overloading:'Overloading',
  exposedKing:'Exposed King', kingsideAttack:'Kingside Attack',
  queensideAttack:'Queenside Attack', attackingF2F7:'Attacking f2/f7',
  advancedPawn:'Advanced Pawn', promotion:'Promotion', underPromotion:'Under-Promotion',
  enPassant:'En Passant', castling:'Castling',
  defensiveMove:'Defensive Move', quietMove:'Quiet Move', zugzwang:'Zugzwang',
  // Mate patterns
  greekGift:'Greek Gift',
  backRankMate:'Back Rank Mate', smotheredMate:'Smothered Mate',
  anastasiaMate:'Anastasia Mate', arabianMate:'Arabian Mate',
  bodenMate:'Boden Mate', dovetailMate:'Dovetail Mate',
  doubleBishopMate:'Double Bishop Mate', balestraMate:'Balestra Mate',
  blindSwineMate:'Blind Swine Mate', cornerMate:'Corner Mate',
  hookMate:'Hook Mate', killBoxMate:'Kill Box Mate',
  morphysMate:"Morphy's Mate", operaMate:'Opera Mate',
  pillsburysMate:"Pillsbury's Mate", triangleMate:'Triangle Mate',
  vukovicMate:'Vukovic Mate', doubleCheckmate:'Double Checkmate',
  // Puzzle metadata
  mate:'Mate', mateIn1:'Mate in 1', mateIn2:'Mate in 2',
  mateIn3:'Mate in 3', mateIn4:'Mate in 4', mateIn5:'Mate in 5',
  oneMove:'One Move', short:'Short', long:'Long', veryLong:'Very Long',
  advantage:'Advantage', crushing:'Crushing', equality:'Equality',
  // Endgame types
  pawnEndgame:'Pawn Endgame', knightEndgame:'Knight Endgame',
  bishopEndgame:'Bishop Endgame', rookEndgame:'Rook Endgame',
  queenEndgame:'Queen Endgame', queenRookEndgame:'Queen + Rook Endgame',
  // FCE endgame segment types
  'Pawn Endings':'Pawn Endings', 'Knight Endings':'Knight Endings',
  'Bishop Endings':'Bishop Endings', 'Bishop vs Knight':'Bishop vs Knight',
  'Rook Endings':'Rook Endings', 'Rook vs Minor Piece':'Rook vs Minor Piece',
  'Rook + Minor vs Rook + Minor':'Rook+Minor vs Rook+Minor',
  'Rook + Minor vs Rook':'Rook+Minor vs Rook',
  'Queen Endings':'Queen Endings', 'Queen vs Rook':'Queen vs Rook',
  'Queen vs Minor Piece':'Queen vs Minor Piece',
  'Queen + Piece vs Queen':'Queen+Piece vs Queen',
};
// Game page: only show game-level tags, not puzzle tactic tags
const GAME_PAGE_TAGS = new Set([
  'Chess.com', 'Lichess',
  'Win', 'Loss', 'Draw',
  'queen_sacrifice', 'rook_sacrifice', 'smothered_mate',
  'titled', 'GM', 'IM', 'FM', 'CM', 'NM',
  'WGM', 'WIM', 'WFM', 'WCM', 'WNM',
]);
function tagDisplayName(tag) {
  if (TAG_DISPLAY[tag]) return TAG_DISPLAY[tag];
  // Convert camelCase or snake_case to readable words
  return tag
    .replace(/_/g, ' ')
    .replace(/([a-z])([A-Z])/g, '$1 $2')
    .replace(/\b\w/g, c => c.toUpperCase());
}
function isGameTag(tag) { return GAME_PAGE_TAGS.has(tag); }

const HIDDEN_PUZZLE_TAGS = new Set([
  'mate','crushing','advantage','equality',
  'oneMove','short','long','veryLong',
  'pawnEndgame','knightEndgame','bishopEndgame','rookEndgame','queenEndgame','queenRookEndgame',
  'queen_sacrifice','rook_sacrifice','smothered_mate',
  'Chess.com','Lichess','Win','Loss','Draw','titled',
  'GM','IM','FM','CM','NM','WGM','WIM','WFM','WCM','WNM',
]);
function isVisibleTag(tag) { return !HIDDEN_PUZZLE_TAGS.has(tag); }

// Time control classification
function getGameType(tc) {
  if (!tc) return { label:'Rapid', color:'text-green-400' };
  if (tc.includes('d') || tc.includes('day')) return { label:'Daily', color:'text-purple-400' };
  const m = tc.match(/^(\d+)/);
  if (!m) return { label:'Rapid', color:'text-green-400' };
  let base = parseInt(m[1]);
  if (base > 60) base = base / 60;
  if (base < 3) return { label:'Bullet', color:'text-yellow-400' };
  if (base < 10) return { label:'Blitz', color:'text-orange-400' };
  if (base < 30) return { label:'Rapid', color:'text-green-400' };
  return { label:'Classical', color:'text-blue-400' };
}

async function initGames() {
  window._gamesInit = true;
  _gamesPage = 1;
  _gamesSelectedTags = new Set();

  const token = localStorage.getItem('alpine_token');
  if (!token) return;
  const headers = { 'Authorization': 'Bearer ' + token };

  // Fetch everything in parallel
  const [storedRes, tagsRes, unanalyzedRes, analyzedRes, backfillRes] = await Promise.all([
    fetch(API_URL + `/api/games/stored?limit=${GAMES_PER_PAGE}&offset=0`, { headers }).catch(() => null),
    fetch(API_URL + '/api/games/tags', { headers }).catch(() => null),
    fetch(API_URL + '/api/games/stored?limit=0&analyzed=false', { headers }).catch(() => null),
    fetch(API_URL + '/api/games/stored?limit=0&analyzed=true', { headers }).catch(() => null),
    fetch(API_URL + '/api/games/backfill/status', { headers }).catch(() => null),
  ]);

  // Parse responses
  const storedData = storedRes?.ok ? await storedRes.json() : { games: [], total: 0 };
  const tagsData = tagsRes?.ok ? await tagsRes.json() : { tags: {} };
  const unanalyzedData = unanalyzedRes?.ok ? await unanalyzedRes.json() : { total: 0 };
  const analyzedData = analyzedRes?.ok ? await analyzedRes.json() : { total: 0 };
  const backfillData = backfillRes?.ok ? await backfillRes.json() : { hasMoreHistory: false };

  _gamesTotal = storedData.total || 0;
  _gamesAllTags = tagsData.tags || {};
  _gamesTotalUnanalyzed = unanalyzedData.total || 0;
  _gamesTotalAnalyzed = analyzedData.total || 0;
  _gamesHasMoreHistory = backfillData.hasMoreHistory || false;

  // Update stats
  renderGamesStats();
  // Update action buttons
  renderGamesActions();
  // Render tags
  renderGamesTags();
  // Render game list
  renderGamesList(storedData.games || []);
  // Render pagination
  renderGamesPagination();
}

function renderGamesStats() {
  const el = document.getElementById('gamesStats');
  el.innerHTML = `<span class="text-white font-mono">${_gamesTotal}</span> games` +
    (_gamesTotalAnalyzed > 0 ? ` <span class="text-good font-mono">(${_gamesTotalAnalyzed} analyzed)</span>` : '');
}

function renderGamesActions() {
  const btnHistory = document.getElementById('btnLoadHistory');
  const btnAnalyze = document.getElementById('btnAnalyze');
  const btnAnalyzeText = document.getElementById('btnAnalyzeText');

  btnHistory.style.display = (_gamesTotal > 0 && _gamesHasMoreHistory) ? 'flex' : 'none';

  if (_gamesTotalUnanalyzed > 0) {
    btnAnalyze.style.display = 'flex';
    btnAnalyzeText.textContent = `Analyze (${_gamesTotalUnanalyzed})`;
  } else {
    btnAnalyze.style.display = 'none';
  }
}

function renderGamesTags() {
  const container = document.getElementById('gamesTagFilters');
  const sortedTags = Object.entries(_gamesAllTags)
    .filter(([tag]) => isGameTag(tag))
    .sort((a, b) => b[1] - a[1]);

  if (sortedTags.length === 0) { container.innerHTML = ''; return; }

  let html = '<span class="text-label text-muted mr-1">Tags:</span>';
  sortedTags.forEach(([tag, count]) => {
    const selected = _gamesSelectedTags.has(tag);
    html += `<button onclick="toggleGamesTag('${tag}')" class="px-2 py-1 text-meta font-medium rounded-md border transition-colors ${
      selected
        ? 'bg-sky-500/20 text-white border-sky-400/50'
        : 'bg-transparent text-secondary border-slate-700 hover:border-slate-500'
    }">${tagDisplayName(tag)} <span class="font-mono text-muted">${count}</span></button>`;
  });

  if (_gamesSelectedTags.size > 0) {
    html += `<button onclick="clearGamesTags()" class="text-label text-muted hover:text-white transition-colors ml-1">Clear</button>`;
  }
  container.innerHTML = html;
}

function renderGamesList(games) {
  // Cache games so analysis page can use SAN moves
  games.forEach(g => { _gamesCache[g.id] = g; });

  const resultLabel = { W:'Won', L:'Lost', D:'Draw' };
  const resultColor = { W:'text-good', L:'text-bad', D:'text-muted' };
  const resultBg = { W:'bg-good/20', L:'bg-red-500/20', D:'bg-slate-600/30' };

  const list = document.getElementById('gamesList');
  if (games.length === 0) {
    list.innerHTML = '<div class="card p-8 text-center text-muted text-label">No games found. Sync your games to get started.</div>';
    return;
  }

  list.innerHTML = games.map((g, i) => {
    const moveCount = Array.isArray(g.moves) ? Math.ceil(g.moves.length / 2) : (g.moves || 0);
    const tc = getGameType(g.timeControl || '');
    const acc = g.userColor === 'white' ? g.whiteAccuracy : g.blackAccuracy;
    const source = g.source === 'lichess' ? 'L' : 'C';
    const sourceBg = g.source === 'lichess' ? 'bg-white/20 text-white' : 'bg-good/20 text-good';
    const tags = (g.tags || []).filter(t => isGameTag(t));
    const finalFen = Array.isArray(g.moves) ? getFinalFen(g.moves) : null;
    const flip = g.userColor === 'black';

    return `
    <div class="card p-4 cursor-pointer transition-all hover:border-sky-400/40 fade-up" onclick="openGame(${g.id})" style="animation-delay:${0.05 + i * 0.03}s">
      <div class="flex items-center justify-between gap-3 min-w-0">
        <div class="flex items-center gap-4 min-w-0">
          ${finalFen ? `<div class="hidden sm:block w-48 h-48 rounded overflow-hidden shrink-0">${fenToMiniBoard(finalFen, flip)}</div>` : ''}
          <div class="min-w-0">
            <div class="flex items-center gap-2 flex-wrap">
              <span class="w-5 h-5 rounded text-meta font-bold flex items-center justify-center shrink-0 ${sourceBg}">${source}</span>
              <span class="text-sm text-white font-medium truncate">vs ${g.opponent}</span>
              ${g.opponentRating ? `<span class="text-label font-mono text-muted">(${g.opponentRating})</span>` : ''}
              <span class="px-1.5 py-0.5 text-label font-semibold rounded ${resultBg[g.result] || ''} ${resultColor[g.result] || 'text-muted'}">${resultLabel[g.result] || g.result}</span>
            </div>
            <div class="flex items-center gap-2 flex-wrap mt-1 text-label text-muted">
              <span class="${tc.color} font-medium">${tc.label}</span>
              ${g.timeControl ? `<span class="text-slate-700">&middot;</span><span>${g.timeControl}</span>` : ''}
              <span class="text-slate-700">&middot;</span>
              <span>${moveCount} moves</span>
              <span class="text-slate-700">&middot;</span>
              <span>as ${g.userColor || 'white'}</span>
              ${tags.map(t => `<span class="px-1.5 py-0.5 text-label rounded border text-good whitespace-nowrap" style="border-color:var(--accent-dim)">${tagDisplayName(t)}</span>`).join('')}
            </div>
          </div>
        </div>
        <div class="flex items-center gap-3 shrink-0">
          ${acc != null ? `<span class="px-2 py-0.5 text-label font-mono font-semibold rounded bg-slate-800/60 ${acc >= 80 ? 'text-good' : acc >= 60 ? 'text-secondary' : 'text-bad'}">${Math.round(acc)}%</span>` : ''}
          ${g.hasAnalysis ? `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="var(--good)" stroke-width="2.5" stroke-linecap="round"><path d="M5 13l4 4L19 7"/></svg>` : ''}
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="text-muted"><path d="M9 18l6-6-6-6"/></svg>
        </div>
      </div>
    </div>`;
  }).join('');
}

function renderGamesPagination() {
  const totalPages = Math.ceil(_gamesTotal / GAMES_PER_PAGE);
  const container = document.getElementById('gamesPagination');

  if (totalPages <= 1) { container.innerHTML = ''; return; }

  const start = (_gamesPage - 1) * GAMES_PER_PAGE + 1;
  const end = Math.min(_gamesPage * GAMES_PER_PAGE, _gamesTotal);
  const isFirst = _gamesPage === 1;
  const isLast = _gamesPage === totalPages;

  const btnClass = (disabled) => disabled
    ? 'px-2 py-1 text-meta text-muted rounded border border-slate-800 opacity-40 cursor-default'
    : 'px-2 py-1 text-meta text-muted rounded border border-slate-700 hover:border-slate-500 cursor-pointer transition-colors';

  container.innerHTML = `
    <p class="text-label text-muted">Showing ${start}–${end} of ${_gamesTotal}</p>
    <div class="flex items-center gap-1">
      <button class="${btnClass(isFirst)}" ${isFirst ? '' : 'onclick="gamesGoToPage(1)"'}>First</button>
      <button class="${btnClass(isFirst)}" ${isFirst ? '' : `onclick="gamesGoToPage(${_gamesPage - 1})"`}>Prev</button>
      <span class="px-3 py-1 text-label text-muted font-mono">Page ${_gamesPage} of ${totalPages}</span>
      <button class="${btnClass(isLast)}" ${isLast ? '' : `onclick="gamesGoToPage(${_gamesPage + 1})"`}>Next</button>
      <button class="${btnClass(isLast)}" ${isLast ? '' : `onclick="gamesGoToPage(${totalPages})"`}>Last</button>
    </div>`;
}

async function gamesGoToPage(page) {
  _gamesPage = page;
  const token = localStorage.getItem('alpine_token');
  if (!token) return;

  const offset = (page - 1) * GAMES_PER_PAGE;
  const tagsParam = _gamesSelectedTags.size > 0 ? `&tags=${encodeURIComponent([..._gamesSelectedTags].join(','))}` : '';
  const res = await fetch(API_URL + `/api/games/stored?limit=${GAMES_PER_PAGE}&offset=${offset}${tagsParam}`, {
    headers: { 'Authorization': 'Bearer ' + token },
  });
  if (!res.ok) return;
  const data = await res.json();
  _gamesTotal = data.total || 0;
  renderGamesList(data.games || []);
  renderGamesPagination();
  // Scroll to top of games list
  document.getElementById('page-games').scrollIntoView({ behavior: 'smooth' });
}

async function toggleGamesTag(tag) {
  if (_gamesSelectedTags.has(tag)) _gamesSelectedTags.delete(tag);
  else _gamesSelectedTags.add(tag);
  _gamesPage = 1;

  const token = localStorage.getItem('alpine_token');
  if (!token) return;
  const headers = { 'Authorization': 'Bearer ' + token };

  // Reload tags with selection context + reload games
  const tagsParam = _gamesSelectedTags.size > 0 ? `?selected_tags=${encodeURIComponent([..._gamesSelectedTags].join(','))}` : '';
  const gamesTagsParam = _gamesSelectedTags.size > 0 ? `&tags=${encodeURIComponent([..._gamesSelectedTags].join(','))}` : '';

  const [tagsRes, gamesRes] = await Promise.all([
    fetch(API_URL + '/api/games/tags' + tagsParam, { headers }),
    fetch(API_URL + `/api/games/stored?limit=${GAMES_PER_PAGE}&offset=0${gamesTagsParam}`, { headers }),
  ]);

  if (tagsRes.ok) { const d = await tagsRes.json(); _gamesAllTags = d.tags || {}; }
  if (gamesRes.ok) { const d = await gamesRes.json(); _gamesTotal = d.total || 0; renderGamesList(d.games || []); }

  renderGamesTags();
  renderGamesPagination();
}

async function clearGamesTags() {
  _gamesSelectedTags = new Set();
  _gamesPage = 1;
  await gamesGoToPage(1);

  const token = localStorage.getItem('alpine_token');
  if (!token) return;
  const tagsRes = await fetch(API_URL + '/api/games/tags', { headers: { 'Authorization': 'Bearer ' + token } });
  if (tagsRes.ok) { const d = await tagsRes.json(); _gamesAllTags = d.tags || {}; }
  renderGamesTags();
}

function showGamesFeedback(msg, type) {
  const el = document.getElementById('gamesFeedback');
  const colors = {
    success: 'bg-cyan-500/20 border border-cyan-500/30 text-cyan-300',
    error: 'bg-red-500/20 border border-red-500/30 text-red-300',
    info: 'bg-violet-500/20 border border-violet-500/30 text-violet-300',
  };
  el.className = `mb-3 px-4 py-2 rounded-lg text-label flex items-center gap-2 ${colors[type] || colors.info}`;
  el.innerHTML = msg;
  setTimeout(() => { el.className = 'hidden mb-3 px-4 py-2 rounded-lg text-label flex items-center gap-2'; }, 8000);
}

async function gamesSync() {
  const btn = document.getElementById('btnSyncGames');
  btn.innerHTML = '<span class="w-3.5 h-3.5 border-2 border-slate-600 border-t-sky-400 rounded-full animate-spin"></span> Syncing...';
  btn.disabled = true;

  try {
    const token = localStorage.getItem('alpine_token');
    const res = await fetch(API_URL + '/api/games/sync', {
      method: 'POST', headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json' }, body: '{}',
    });
    if (!res.ok) throw new Error('Sync failed');
    const data = await res.json();
    if (data.hasMoreHistory !== undefined) _gamesHasMoreHistory = data.hasMoreHistory;
    showGamesFeedback(`Synced ${data.synced} games`, 'success');

    // Invalidate dashboard so it re-fetches on next visit
    window._dashInit = false;

    // Reload everything
    _gamesPage = 1;
    _gamesSelectedTags = new Set();
    window._gamesInit = false;
    await initGames();
  } catch (err) {
    showGamesFeedback(err.message, 'error');
  } finally {
    btn.innerHTML = '<svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/></svg> Sync Games';
    btn.disabled = false;
  }
}

async function gamesBackfill() {
  const btn = document.getElementById('btnLoadHistory');
  btn.innerHTML = '<span class="w-3.5 h-3.5 border-2 border-white/30 border-t-white rounded-full animate-spin"></span> Loading...';
  btn.disabled = true;

  try {
    const token = localStorage.getItem('alpine_token');
    const res = await fetch(API_URL + '/api/games/backfill', {
      method: 'POST', headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json' }, body: '{}',
    });
    if (!res.ok) throw new Error('Backfill failed');
    const data = await res.json();
    _gamesHasMoreHistory = data.hasMoreHistory;
    showGamesFeedback(`Loaded ${data.synced} older games`, 'info');

    // Invalidate dashboard so it re-fetches on next visit
    window._dashInit = false;

    window._gamesInit = false;
    await initGames();
  } catch (err) {
    showGamesFeedback(err.message, 'error');
  } finally {
    btn.innerHTML = '<svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/></svg> Load More History';
    btn.disabled = false;
  }
}

async function gamesAnalyze() {
  const btn = document.getElementById('btnAnalyze');
  const btnText = document.getElementById('btnAnalyzeText');
  btnText.textContent = 'Queueing...';
  btn.disabled = true;

  try {
    const token = localStorage.getItem('alpine_token');
    const res = await fetch(API_URL + '/api/games/analyze-server', {
      method: 'POST', headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json' },
      body: JSON.stringify({ all_unanalyzed: true, limit: 1000 }),
    });
    if (!res.ok) throw new Error('Analysis failed');
    const data = await res.json();
    showGamesFeedback(`Queued ${data.queued} games for analysis. Results will appear automatically.`, 'success');
  } catch (err) {
    showGamesFeedback(err.message, 'error');
  } finally {
    btnText.textContent = `Analyze (${_gamesTotalUnanalyzed})`;
    btn.disabled = false;
  }
}

function openGame(id, source) {
  setAnalysisBackButton(source || 'games');
  loadGameAnalysis(id);
}

// ══════════════════════════════════════════
// ANALYSIS PAGE INIT
// ══════════════════════════════════════════
let _currentGameId = null;
let _analysisSource = 'games'; // tracks where user came from: 'games' or 'dashboard'

function analysisGoBack() {
  switchPage(_analysisSource);
}

function setAnalysisBackButton(source) {
  _analysisSource = source;
  const label = document.getElementById('analysisBackLabel');
  if (label) label.textContent = source === 'dashboard' ? 'Back to Dashboard' : 'Back to Games';
}

function initAnalysis() {
  window._analysisInit = true;
  setCgBoard('rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1', 'white');
}

function setCgBoard(fen, orientation) {
  if (!Chessground) {
    // Libs not loaded yet, retry shortly
    setTimeout(() => setCgBoard(fen, orientation), 200);
    return;
  }
  const el = document.getElementById('chessboard');
  if (_cgInstance) {
    _cgInstance.set({ fen, orientation, viewOnly: true });
  } else {
    el.innerHTML = '';
    _cgInstance = Chessground(el, {
      fen,
      orientation,
      viewOnly: true,
      coordinates: true,
      animation: { duration: 250 },
    });
    setTimeout(resizeBoards, 50);
  }
}

async function loadGameAnalysis(gameId) {
  _currentGameId = gameId;
  window._analysisInit = true;
  switchPage('analysis');

  const token = localStorage.getItem('alpine_token');
  if (!token) return;
  const headers = { 'Authorization': 'Bearer ' + token };

  // Fetch game + analysis in parallel
  const [gameRes, analysisRes] = await Promise.all([
    fetch(API_URL + `/api/games/${gameId}`, { headers }).catch(() => null),
    fetch(API_URL + `/api/games/${gameId}/analysis`, { headers }).catch(() => null),
  ]);

  const game = gameRes?.ok ? await gameRes.json() : null;
  const analysis = analysisRes?.ok ? await analysisRes.json() : null;

  if (!game) {
    document.getElementById('analysisHeader').innerHTML = '<div class="text-center py-4 text-label text-bad">Game not found</div>';
    return;
  }

  // Get SAN moves (prefer cached from games list)
  const cached = _gamesCache[gameId];
  const sanMoves = (cached && Array.isArray(cached.moves)) ? cached.moves : (Array.isArray(game.moves) ? game.moves : []);

  // Build positions array using chess.js
  _analysisPositions = [];
  _analysisMoveIndex = -1;
  _analysisMoveCount = sanMoves.length;

  if (Chess && sanMoves.length > 0) {
    _chessInstance = new Chess();
    _analysisPositions.push(_chessInstance.fen()); // starting position = index -1
    for (const san of sanMoves) {
      try { _chessInstance.move(san); } catch { break; }
      _analysisPositions.push(_chessInstance.fen());
    }
    _analysisMoveCount = _analysisPositions.length - 1; // exclude starting pos
  }

  // Store analysis data for eval bar updates
  window._analysisData = analysis;

  const userSide = game.userColor || 'white';
  const oppSide = userSide === 'white' ? 'black' : 'white';

  // Header
  const user = JSON.parse(localStorage.getItem('alpine_user') || '{}');
  const username = user.chessComUsername || user.username || 'You';
  const userRating = game.userRating || '?';
  const oppRating = game.opponentRating || '?';
  const moveCount = Math.ceil(sanMoves.length / 2);
  const resultMap = { W: '1 - 0', L: '0 - 1', D: '½ - ½' };
  const resultColor = { W: 'text-good', L: 'text-bad', D: 'text-muted' };

  document.getElementById('analysisHeader').innerHTML = `
    <div class="flex items-center justify-between">
      <div>
        <div class="flex items-center gap-2">
          <span class="text-sm font-semibold text-white">${username}</span>
          <span class="text-label font-mono text-muted">(${userRating})</span>
          <span class="text-label ${resultColor[game.result] || 'text-muted'} font-semibold">${resultMap[game.result] || game.result}</span>
          <span class="text-label font-mono text-muted">(${oppRating})</span>
          <span class="text-sm font-semibold text-white">${game.opponent}</span>
        </div>
        <div class="flex items-center gap-3 mt-1 text-label text-muted">
          ${game.timeControl ? `<span>${game.timeControl}</span><span>&middot;</span>` : ''}
          <span>${moveCount} moves</span>
          ${game.date ? `<span>&middot;</span><span>${new Date(game.date).toLocaleDateString('en', { month:'short', day:'numeric', year:'numeric' })}</span>` : ''}
        </div>
      </div>
    </div>`;

  // Set board to starting position with user's color orientation
  setCgBoard('rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1', userSide);

  // Move quality grid
  const qualityClass = { book:'move-book', best:'move-best', excellent:'move-excellent', good:'move-good', inaccuracy:'move-inaccuracy', mistake:'move-mistake', blunder:'move-blunder', forced:'text-muted' };

  if (analysis && analysis.moves) {
    const counts = { white: {}, black: {} };
    const qualities = ['book','best','excellent','good','inaccuracy','mistake','blunder','forced'];
    qualities.forEach(q => { counts.white[q] = 0; counts.black[q] = 0; });

    analysis.moves.forEach((m, i) => {
      const side = i % 2 === 0 ? 'white' : 'black';
      const q = (m.classification || '').toLowerCase();
      if (counts[side][q] !== undefined) counts[side][q]++;
    });

    let mqHtml = `<div class="grid grid-cols-[1fr_50px_50px] gap-x-3 gap-y-1.5 text-label">
      <div></div>
      <div class="text-center text-meta text-muted uppercase tracking-wider font-medium">You</div>
      <div class="text-center text-meta text-muted uppercase tracking-wider font-medium" style="opacity:0.6">Opp</div>`;

    qualities.forEach(q => {
      const bgClass = q === 'forced' ? 'bg-slate-600/80' : `bg-move-${q}`;
      mqHtml += `
        <div class="flex items-center gap-1.5"><span class="w-1.5 h-1.5 rounded-sm ${bgClass}"></span><span class="text-muted">${q.charAt(0).toUpperCase() + q.slice(1)}</span></div>
        <div class="text-center font-mono text-white">${counts[userSide][q]}</div>
        <div class="text-center font-mono text-muted" style="opacity:0.6">${counts[oppSide][q]}</div>`;
    });

    const userAcc = userSide === 'white' ? analysis.white_accuracy : analysis.black_accuracy;
    const oppAcc = oppSide === 'white' ? analysis.white_accuracy : analysis.black_accuracy;
    mqHtml += `</div><div class="gradient-line mt-3 mb-3"></div>
      <div class="grid grid-cols-[1fr_50px_50px] gap-x-3 text-label">
        <div class="flex items-center gap-1.5"><span class="text-muted font-medium">Accuracy</span></div>
        <div class="text-center font-mono font-bold text-good">${userAcc != null ? Math.round(userAcc) + '%' : '—'}</div>
        <div class="text-center font-mono font-semibold text-muted" style="opacity:0.6">${oppAcc != null ? Math.round(oppAcc) + '%' : '—'}</div>
      </div>`;

    document.getElementById('analysisMqGrid').innerHTML = mqHtml;
  } else {
    document.getElementById('analysisMqGrid').innerHTML = '<div class="text-label text-muted py-2">No analysis data. Queue this game for analysis on the Games page.</div>';
  }

  // Move list — clickable moves
  const ml = document.getElementById('moveList');
  let moveHtml = '';
  const aMoves = analysis?.moves || [];
  for (let i = 0; i < sanMoves.length; i += 2) {
    const moveNum = Math.floor(i / 2) + 1;
    const wSan = sanMoves[i] || '';
    const bSan = sanMoves[i + 1] || '';
    const wClass = aMoves[i] ? (aMoves[i].classification || '').toLowerCase() : '';
    const bClass = aMoves[i + 1] ? (aMoves[i + 1].classification || '').toLowerCase() : '';

    moveHtml += `<span class="text-secondary mr-1">${moveNum}.</span>`;
    moveHtml += `<span class="move-item ${qualityClass[wClass] || ''}" data-mi="${i}" onclick="analysisGoTo(${i})">${wSan}</span> `;
    if (bSan) moveHtml += `<span class="move-item ${qualityClass[bClass] || ''}" data-mi="${i+1}" onclick="analysisGoTo(${i+1})">${bSan}</span> `;
  }
  ml.innerHTML = moveHtml;

  // Update eval bar to starting position
  updateEvalBar(-1);
}

// ── Move navigation ──
function analysisGoTo(idx) {
  if (idx < -1 || idx >= _analysisMoveCount) return;
  _analysisMoveIndex = idx;
  const fen = _analysisPositions[idx + 1]; // +1 because index 0 = starting pos
  if (fen && _cgInstance) {
    _cgInstance.set({ fen, animation: { enabled: true } });
  }
  updateEvalBar(idx);
  highlightActiveMove(idx);
}

function analysisNav(dir) {
  switch (dir) {
    case 'first': analysisGoTo(-1); break;
    case 'prev': analysisGoTo(_analysisMoveIndex - 1); break;
    case 'next': analysisGoTo(_analysisMoveIndex + 1); break;
    case 'last': analysisGoTo(_analysisMoveCount - 1); break;
  }
}

function updateEvalBar(moveIdx) {
  const analysis = window._analysisData;
  const fillEl = document.getElementById('analysisEvalFill');
  const textEl = document.getElementById('analysisEvalText');
  if (!fillEl || !textEl) return;

  if (!analysis || !analysis.moves || moveIdx < 0) {
    fillEl.style.height = '50%';
    textEl.textContent = '0.0';
    return;
  }

  const m = analysis.moves[moveIdx];
  if (!m) return;

  // Use move_eval (from white's perspective)
  const cp = m.move_eval ?? 0;
  // Convert centipawns to bar height (50% = even, clamped 5-95%)
  const pct = Math.max(5, Math.min(95, 50 + (cp / 10)));
  fillEl.style.height = pct + '%';

  // Format eval text
  if (Math.abs(cp) > 9000) {
    textEl.textContent = cp > 0 ? 'M' : '-M';
  } else {
    textEl.textContent = (cp >= 0 ? '+' : '') + (cp / 100).toFixed(1);
  }
}

function highlightActiveMove(idx) {
  document.querySelectorAll('#moveList .move-item').forEach(el => {
    el.classList.remove('active-move');
  });
  if (idx >= 0) {
    const el = document.querySelector(`#moveList .move-item[data-mi="${idx}"]`);
    if (el) {
      el.classList.add('active-move');
      el.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
    }
  }
}

// ── Opening Line Viewer (from dashboard habits) ──
function openOpeningLine(type, idx) {
  const data = type === 'blunder' ? (window._openingBlunders || [])[idx] : (window._cleanLines || [])[idx];
  if (!data || !data.moves || !Chess) return;

  // Build positions from SAN moves
  _analysisPositions = [];
  _chessInstance = new Chess();
  _analysisPositions.push(_chessInstance.fen());
  for (const san of data.moves) {
    try { _chessInstance.move(san); } catch { break; }
    _analysisPositions.push(_chessInstance.fen());
  }
  _analysisMoveCount = _analysisPositions.length - 1;

  const userSide = data.color || 'white';
  const userIsWhite = userSide === 'white';

  // Build synthetic analysis (like React's OpeningLinePage)
  const syntheticMoves = data.moves.map((san, i) => {
    const isUserMove = userIsWhite ? (i % 2 === 0) : (i % 2 === 1);
    let classification = 'book', cpLoss = 0, bestMove = '';
    if (type === 'blunder' && i === data.ply && isUserMove) {
      cpLoss = data.avgCpLoss;
      classification = cpLoss >= 200 ? 'blunder' : cpLoss >= 100 ? 'mistake' : cpLoss >= 50 ? 'inaccuracy' : 'good';
      bestMove = data.bestMove || '';
    }
    return { move: san, move_eval: 0, best_move: bestMove, best_eval: 0, cp_loss: cpLoss, classification };
  });

  // Build classification counts
  const counts = { white: {}, black: {} };
  const qualities = ['book','best','excellent','good','inaccuracy','mistake','blunder','forced'];
  qualities.forEach(q => { counts.white[q] = 0; counts.black[q] = 0; });
  syntheticMoves.forEach((m, i) => {
    const side = i % 2 === 0 ? 'white' : 'black';
    if (counts[side][m.classification] !== undefined) counts[side][m.classification]++;
  });

  window._analysisData = { moves: syntheticMoves, white_accuracy: null, black_accuracy: null };

  // Switch to analysis page
  setAnalysisBackButton('dashboard');
  switchPage('analysis');
  window._analysisInit = true;

  // Header
  const subtitle = type === 'blunder'
    ? `Repeated ${data.mistakeCount} times as ${data.color} · avg -${data.avgCpLoss} cp`
    : `${data.cleanDepth} moves deep as ${data.color} · ${data.gameCount} game${data.gameCount === 1 ? '' : 's'}`;

  document.getElementById('analysisHeader').innerHTML = `
    <div>
      <div class="text-sm font-semibold text-white">${data.line}</div>
      <div class="text-label text-muted mt-0.5">${subtitle}</div>
    </div>`;

  setCgBoard('rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1', userSide);

  // Move quality grid
  const qualityClass = { book:'move-book', best:'move-best', excellent:'move-excellent', good:'move-good', inaccuracy:'move-inaccuracy', mistake:'move-mistake', blunder:'move-blunder', forced:'text-muted' };
  const oppSide = userSide === 'white' ? 'black' : 'white';
  let mqHtml = `<div class="grid grid-cols-[1fr_50px_50px] gap-x-3 gap-y-1.5 text-label">
    <div></div>
    <div class="text-center text-meta text-muted uppercase tracking-wider font-medium">You</div>
    <div class="text-center text-meta text-muted uppercase tracking-wider font-medium" style="opacity:0.6">Opp</div>`;
  qualities.forEach(q => {
    const bgClass = q === 'forced' ? 'bg-slate-600/80' : `bg-move-${q}`;
    mqHtml += `
      <div class="flex items-center gap-1.5"><span class="w-1.5 h-1.5 rounded-sm ${bgClass}"></span><span class="text-muted">${q.charAt(0).toUpperCase() + q.slice(1)}</span></div>
      <div class="text-center font-mono text-white">${counts[userSide][q]}</div>
      <div class="text-center font-mono text-muted" style="opacity:0.6">${counts[oppSide][q]}</div>`;
  });
  mqHtml += `</div>`;
  document.getElementById('analysisMqGrid').innerHTML = mqHtml;

  // Move list
  const ml = document.getElementById('moveList');
  let moveHtml = '';
  for (let i = 0; i < data.moves.length; i += 2) {
    const moveNum = Math.floor(i / 2) + 1;
    const wSan = data.moves[i] || '';
    const bSan = data.moves[i + 1] || '';
    const wClass = syntheticMoves[i] ? syntheticMoves[i].classification : '';
    const bClass = syntheticMoves[i + 1] ? syntheticMoves[i + 1].classification : '';
    moveHtml += `<span class="text-secondary mr-1">${moveNum}.</span>`;
    moveHtml += `<span class="move-item ${qualityClass[wClass] || ''}" data-mi="${i}" onclick="analysisGoTo(${i})">${wSan}</span> `;
    if (bSan) moveHtml += `<span class="move-item ${qualityClass[bClass] || ''}" data-mi="${i+1}" onclick="analysisGoTo(${i+1})">${bSan}</span> `;
  }
  ml.innerHTML = moveHtml;

  // Jump to blunder move, or start for clean lines
  const startIdx = type === 'blunder' ? data.ply : -1;
  _analysisMoveIndex = -1;
  analysisGoTo(startIdx);
}

// Keyboard navigation for analysis
document.addEventListener('keydown', (e) => {
  // Only when on analysis page
  const analysisPage = document.getElementById('page-analysis');
  if (!analysisPage || !analysisPage.classList.contains('active')) return;

  if (e.key === 'ArrowLeft') { e.preventDefault(); analysisNav('prev'); }
  else if (e.key === 'ArrowRight') { e.preventDefault(); analysisNav('next'); }
  else if (e.key === 'Home') { e.preventDefault(); analysisNav('first'); }
  else if (e.key === 'End') { e.preventDefault(); analysisNav('last'); }
});

// ══════════════════════════════════════════
// PROFILE PAGE INIT
// ══════════════════════════════════════════
let _currentProfile = null; // cache for edit modal

async function initProfile() {
  window._profileInit = true;
  const user = JSON.parse(localStorage.getItem('alpine_user') || '{}');
  const token = localStorage.getItem('alpine_token');
  if (!user.username) return;

  // Fetch profile from API for game count
  let profile = null;
  try {
    const res = await fetch(API_URL + `/api/users/${user.username}`, { headers: { 'Authorization': 'Bearer ' + token } });
    if (res.ok) profile = await res.json();
  } catch {}

  _currentProfile = profile;

  renderProfile(user, profile);
}

function renderProfile(user, profile) {
  const displayName = profile?.displayName || user.displayName || user.username;
  const bio = profile?.bio || user.bio || '';
  const gamesCount = profile?.gamesCount || 0;
  const chessComUser = profile?.chessComUsername || user.chessComUsername || '';
  const initials = displayName.slice(0, 2).toUpperCase();

  document.getElementById('profileCard').innerHTML = `
    <div class="flex flex-col sm:flex-row items-center sm:items-start gap-4 sm:gap-5">
      <div class="w-20 h-20 rounded-xl bg-gradient-to-br from-sky-300 via-sky-400 to-cyan-500 flex items-center justify-center text-2xl font-bold text-black shadow-lg shadow-sky-500/20 shrink-0">${initials}</div>
      <div class="flex-1 min-w-0 text-center sm:text-left">
        <div class="flex items-center justify-center sm:justify-start gap-3 flex-wrap">
          <h1 class="text-xl font-bold text-white">${displayName}</h1>
          <button onclick="openEditProfile()"
            class="px-3 py-1.5 rounded-lg text-label font-medium text-muted border border-slate-700 hover:bg-slate-800 hover:text-white transition-colors">
            Edit Profile
          </button>
        </div>
        <p class="text-body text-secondary mt-0.5">@${user.username}</p>
        ${bio ? `<p class="text-body text-secondary mt-2 leading-relaxed">${esc(bio)}</p>` : ''}
        <div class="flex items-center justify-center sm:justify-start gap-4 sm:gap-6 mt-4 flex-wrap">
          <div>
            <p class="text-lg font-bold font-mono text-white">${gamesCount}</p>
            <p class="text-meta text-secondary uppercase tracking-wider">Games</p>
          </div>
          ${chessComUser ? `
          <div class="hidden sm:block w-px h-8 bg-slate-800"></div>
          <div class="flex items-center gap-1.5 px-2.5 py-1.5 rounded-md bg-slate-900/80 border border-slate-800/60">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none"><circle cx="12" cy="12" r="10" stroke="var(--text-muted)" stroke-width="1.5"/><path d="M8 12l3 3 5-5" stroke="var(--accent)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
            <span class="text-label text-muted">Chess.com</span>
            <span class="text-label font-mono text-white font-medium">${esc(chessComUser)}</span>
          </div>` : `
          <div class="hidden sm:block w-px h-8 bg-slate-800"></div>
          <button onclick="openEditProfile()"
            class="flex items-center gap-1.5 px-2.5 py-1.5 rounded-md bg-slate-900/80 border border-slate-800/60 hover:bg-slate-800 transition-colors cursor-pointer">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="var(--text-dim)" stroke-width="2" stroke-linecap="round"><path d="M12 5v14M5 12h14"/></svg>
            <span class="text-label text-muted">Link Chess.com</span>
          </button>`}
        </div>
      </div>
    </div>

    <!-- Logout -->
    <div class="mt-5 pt-4" style="border-top:1px solid var(--border-subtle)">
      <button onclick="logoutUser()"
        class="flex items-center gap-2 px-3 py-2 rounded-lg text-label font-medium text-muted hover:text-white hover:bg-slate-800 transition-colors">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M9 21H5a2 2 0 01-2-2V5a2 2 0 012-2h4"/><polyline points="16 17 21 12 16 7"/><line x1="21" y1="12" x2="9" y2="12"/></svg>
        Sign Out
      </button>
    </div>`;
}

// HTML escape helper
function esc(str) {
  const d = document.createElement('div');
  d.textContent = str;
  return d.innerHTML;
}

// ── Edit Profile Modal ──
function openEditProfile() {
  const user = JSON.parse(localStorage.getItem('alpine_user') || '{}');
  const profile = _currentProfile;
  const displayName = profile?.displayName || user.displayName || user.username;
  const bio = profile?.bio || user.bio || '';
  const chessComUser = profile?.chessComUsername || user.chessComUsername || '';

  document.getElementById('edit-displayName').value = displayName;
  document.getElementById('edit-bio').value = bio;
  document.getElementById('edit-chesscom').value = chessComUser;
  document.getElementById('edit-displayName-count').textContent = displayName.length;
  document.getElementById('edit-bio-count').textContent = bio.length;
  document.getElementById('edit-profile-error').classList.add('hidden');
  hideDeleteConfirm();
  document.getElementById('edit-profile-modal').style.display = 'flex';
}

function closeEditProfile() {
  document.getElementById('edit-profile-modal').style.display = 'none';
}

// Character counters
document.getElementById('edit-displayName').addEventListener('input', function() {
  document.getElementById('edit-displayName-count').textContent = this.value.length;
});
document.getElementById('edit-bio').addEventListener('input', function() {
  document.getElementById('edit-bio-count').textContent = this.value.length;
});

// Save profile
document.getElementById('edit-profile-form').addEventListener('submit', async (e) => {
  e.preventDefault();
  const errEl = document.getElementById('edit-profile-error');
  const saveBtn = document.getElementById('edit-profile-save-btn');
  errEl.classList.add('hidden');

  const displayName = document.getElementById('edit-displayName').value.trim();
  const bio = document.getElementById('edit-bio').value.trim();
  const chessComUsername = document.getElementById('edit-chesscom').value.trim();

  if (!displayName) {
    errEl.textContent = 'Display name cannot be empty';
    errEl.classList.remove('hidden');
    return;
  }

  const token = localStorage.getItem('alpine_token');
  const user = JSON.parse(localStorage.getItem('alpine_user') || '{}');
  const profile = _currentProfile;

  // Only include changed fields
  const data = {};
  if (displayName !== (profile?.displayName || user.displayName || user.username)) data.displayName = displayName;
  if (bio !== (profile?.bio || '')) data.bio = bio;
  if (chessComUsername !== (profile?.chessComUsername || '')) data.chessComUsername = chessComUsername;

  if (Object.keys(data).length === 0) {
    closeEditProfile();
    return;
  }

  saveBtn.textContent = 'Saving...';
  saveBtn.disabled = true;

  try {
    const res = await fetch(API_URL + '/api/users/me', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + token },
      body: JSON.stringify(data),
    });
    if (!res.ok) {
      const err = await res.json().catch(() => ({}));
      throw new Error(err.detail || 'Failed to update profile');
    }
    const updated = await res.json();
    _currentProfile = updated;

    // Update local storage
    user.displayName = updated.displayName;
    user.bio = updated.bio;
    user.chessComUsername = updated.chessComUsername;
    localStorage.setItem('alpine_user', JSON.stringify(user));

    // If Chess.com was newly linked, trigger game sync in background
    const wasLinked = profile?.chessComUsername;
    if (!wasLinked && data.chessComUsername) {
      fetch(API_URL + '/api/games/sync', {
        method: 'POST',
        headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json' },
        body: '{}',
      })
        .then(() => console.log('Initial games sync started'))
        .catch(err => console.error('Failed to start games sync:', err));
    }

    renderProfile(user, updated);
    closeEditProfile();
  } catch (err) {
    errEl.textContent = err.message;
    errEl.classList.remove('hidden');
  } finally {
    saveBtn.textContent = 'Save Changes';
    saveBtn.disabled = false;
  }
});

// ── Delete Account ──
function showDeleteConfirm() {
  document.getElementById('delete-account-section').classList.add('hidden');
  document.getElementById('delete-confirm-section').classList.remove('hidden');
}

function hideDeleteConfirm() {
  document.getElementById('delete-account-section').classList.remove('hidden');
  document.getElementById('delete-confirm-section').classList.add('hidden');
}

async function confirmDeleteAccount() {
  const btn = document.getElementById('confirm-delete-btn');
  const errEl = document.getElementById('edit-profile-error');
  btn.textContent = 'Deleting...';
  btn.disabled = true;
  errEl.classList.add('hidden');

  try {
    const token = localStorage.getItem('alpine_token');
    const res = await fetch(API_URL + '/api/users/me', {
      method: 'DELETE',
      headers: { 'Authorization': 'Bearer ' + token },
    });
    if (!res.ok) {
      const err = await res.json().catch(() => ({}));
      throw new Error(err.detail || 'Failed to delete account');
    }
    logoutUser();
  } catch (err) {
    errEl.textContent = err.message;
    errEl.classList.remove('hidden');
    btn.textContent = 'Confirm Delete';
    btn.disabled = false;
  }
}

// ── Logout ──
function logoutUser() {
  localStorage.removeItem('alpine_token');
  localStorage.removeItem('alpine_user');
  _currentProfile = null;
  window._profileInit = false;
  closeEditProfile();
  showLogin();
}

// ══════════════════════════════════════════
// AUTH + INIT
// ══════════════════════════════════════════
function showApp() {
  document.getElementById('login-page').style.display = 'none';
  document.getElementById('app-shell').style.display = 'flex';
  document.getElementById('mobile-nav').style.display = '';
  initDashboard();
}

function showLogin() {
  document.getElementById('login-page').style.display = 'flex';
  document.getElementById('app-shell').style.display = 'none';
}

document.getElementById('login-form').addEventListener('submit', async (e) => {
  e.preventDefault();
  const btn = document.getElementById('login-btn');
  const errEl = document.getElementById('login-error');
  const username = document.getElementById('login-username').value;
  const password = document.getElementById('login-password').value;

  btn.textContent = 'Signing in...';
  btn.disabled = true;
  errEl.classList.add('hidden');

  try {
    const res = await fetch(API_URL + '/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ username, password }),
    });
    if (!res.ok) {
      const data = await res.json().catch(() => ({}));
      throw new Error(data.detail || 'Login failed');
    }
    const data = await res.json();
    localStorage.setItem('alpine_token', data.token);
    localStorage.setItem('alpine_user', JSON.stringify(data.user));
    showApp();
  } catch (err) {
    errEl.textContent = err.message;
    errEl.classList.remove('hidden');
  } finally {
    btn.textContent = 'Sign in';
    btn.disabled = false;
  }
});

// Console-only registration: registerUser('username', 'password')
window.registerUser = async function(username, password) {
  try {
    const res = await fetch(API_URL + '/api/auth/register', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ username, password }),
    });
    const data = await res.json().catch(() => ({}));
    if (!res.ok) throw new Error(data.detail || 'Registration failed');
    console.log('Registered successfully:', data.user);
    return data;
  } catch (err) {
    console.error('Registration error:', err.message);
  }
};

// Check for existing session — validate token with /api/auth/me
(async function checkSession() {
  const token = localStorage.getItem('alpine_token');
  if (!token) { showLogin(); return; }

  try {
    const res = await fetch(API_URL + '/api/auth/me', {
      headers: { 'Authorization': 'Bearer ' + token },
    });
    if (!res.ok) throw new Error('Invalid token');
    const data = await res.json();
    if (data.user) localStorage.setItem('alpine_user', JSON.stringify(data.user));
    showApp();
  } catch {
    localStorage.removeItem('alpine_token');
    localStorage.removeItem('alpine_user');
    showLogin();
  }
})();

// Navigate to hash on initial load (must be after all variable declarations)
(function() {
  const page = location.hash.slice(1);
  if (page && document.getElementById('page-' + page)) switchPage(page, true);
})();
</script>

<!-- ─── Mobile Bottom Nav ─── -->
<nav id="mobile-nav" class="fixed bottom-0 left-0 right-0 h-16 bg-black/95 backdrop-blur border-t border-slate-800/50 flex items-center justify-around z-50 lg:hidden" style="display:none">
  <button onclick="switchPage('dashboard')" class="mobile-nav-item active" data-page="dashboard">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7" rx="1"/><rect x="14" y="3" width="7" height="7" rx="1"/><rect x="3" y="14" width="7" height="7" rx="1"/><rect x="14" y="14" width="7" height="7" rx="1"/></svg>
    <span class="text-[10px] mt-0.5">Dashboard</span>
  </button>
  <button onclick="switchPage('puzzles')" class="mobile-nav-item" data-page="puzzles">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/></svg>
    <span class="text-[10px] mt-0.5">Puzzles</span>
  </button>
  <button onclick="switchPage('trainer')" class="mobile-nav-item" data-page="trainer">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 19h16M4 15h16M4 11h8"/></svg>
    <span class="text-[10px] mt-0.5">Trainer</span>
  </button>
  <button onclick="switchPage('games')" class="mobile-nav-item" data-page="games">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M2 12h5l3-9 4 18 3-9h5"/></svg>
    <span class="text-[10px] mt-0.5">Games</span>
  </button>
  <button onclick="switchPage('profile')" class="mobile-nav-item" data-page="profile">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="8" r="4"/><path d="M4 20c0-4 4-7 8-7s8 3 8 7"/></svg>
    <span class="text-[10px] mt-0.5">Profile</span>
  </button>
</nav>

</body>
</html>
